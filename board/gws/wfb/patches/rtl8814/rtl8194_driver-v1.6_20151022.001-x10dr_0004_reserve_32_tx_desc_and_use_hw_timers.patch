From 872a171d6e4277b032a5312a538f704b6fafd5ce Mon Sep 17 00:00:00 2001
From: Hoang Tran <hoang.tran@greenwavereality.com>
Date: Fri, 31 Mar 2017 16:34:08 -0700
Subject: [PATCH] use hw timer

---
 driver/rtl8192cd/8192c_reg.h                  |    1 +
 driver/rtl8192cd/8192cd.h                     |   72 +-
 driver/rtl8192cd/8192cd_cfg.h                 |    9 +
 driver/rtl8192cd/8192cd_headers.h             |   20 +-
 driver/rtl8192cd/8192cd_hw.c                  |   30 +-
 driver/rtl8192cd/8192cd_ioctl.c               |   31 +-
 driver/rtl8192cd/8192cd_osdep.c               |   88 ++
 driver/rtl8192cd/8192cd_proc.c                |    7 +-
 driver/rtl8192cd/8192cd_rx.c                  |    4 +
 driver/rtl8192cd/8192cd_rx.h                  |    8 +
 driver/rtl8192cd/8192cd_sme.c                 |   32 +-
 driver/rtl8192cd/8192cd_tx.c                  | 1147 ++++++++++++++-----------
 driver/rtl8192cd/8192cd_util.c                |  211 +++--
 driver/rtl8192cd/8192cd_util.h                |    1 +
 driver/rtl8192cd/EdcaTurboCheck.c             |  188 ++--
 driver/rtl8192cd/WlanHAL/HalDef.h             |    2 +
 driver/rtl8192cd/WlanHAL/RTL88XX/Hal88XXIsr.c |   12 +
 17 files changed, 1163 insertions(+), 700 deletions(-)

diff --git a/driver/rtl8192cd/8192c_reg.h b/driver/rtl8192cd/8192c_reg.h
index 84117b4..c3c42ce 100755
--- a/driver/rtl8192cd/8192c_reg.h
+++ b/driver/rtl8192cd/8192c_reg.h
@@ -256,6 +256,7 @@
 #define		RXTSF_OFFSET_OFDM	0x55F	// OFDM BCN OFFSET.
 #define		TSFTR				0x560	// TSF Timer.
 #define		INIT_TSFTR			0x564	// TSF Timer Initial Value.
+#define		TSFTR1				0x568	// TSF Timer1.
 #define		PSTIMER			0x580	// PS TIMER and Timeout INT.
 #define		TIMER0				0x584	// TIMER0 INT.
 #define		TIMER1				0x588	// TIMER1 INT.
diff --git a/driver/rtl8192cd/8192cd.h b/driver/rtl8192cd/8192cd.h
index ba54872..a33d859 100755
--- a/driver/rtl8192cd/8192cd.h
+++ b/driver/rtl8192cd/8192cd.h
@@ -1035,6 +1035,7 @@ struct tx_insn	{
 	unsigned char		is_dhcp;
 	unsigned char		is_mcast;
 #endif
+	unsigned char		is_urg_pkt;
 #ifdef WDS
 	int					wdsIdx;
 #endif
@@ -1142,22 +1143,21 @@ struct rx_sc_entry {
 #define MAX_BACKOFF_CNT		8
 
 struct sw_tx_q {
-	struct sk_buff_head     be_queue;
-	struct sk_buff_head     bk_queue;
-	struct sk_buff_head     vi_queue;
-	struct sk_buff_head     vo_queue;
-	struct timer_list       beq_timer;
-	struct timer_list       bkq_timer;
-	struct timer_list       viq_timer;
-	struct timer_list       voq_timer;
-	int           			beq_empty;      //0:empty; 1:not empty
-	int           			bkq_empty;
-	int           			viq_empty;
-	int           			voq_empty;
 	int						q_aggnum[8];
 	int						q_TOCount[8];
 	unsigned char 			q_used[8];
-	unsigned char			q_aggnumIncSlow[8];
+	struct sk_buff_head		swq_queue[8];
+	unsigned short			swq_timer_id[8];    
+	unsigned char			swq_empty[8];      //0:empty; 1:not empty    
+
+    /* below is for old swq*/
+    unsigned char			q_aggnumIncSlow[8];
+
+    /* below is for new swq*/
+    unsigned char           swq_en[8];
+    unsigned long           swq_keeptime[8];
+    unsigned char           swq_timeout_change[8];        
+    unsigned char           swq_prev_timeout[8];  
 };
 #endif
 
@@ -1616,6 +1616,11 @@ struct aid_obj {
 struct extra_stats {
 	unsigned long		tx_retrys;
 	unsigned long		tx_drops;
+#ifdef SW_TX_QUEUE	
+	unsigned long       swq_enque_pkt;	
+	unsigned long       swq_xmit_out_pkt;
+    unsigned long       swq_drop_pkt;
+#endif	
 	unsigned long		rx_retrys;
 	unsigned long		rx_decache;
 	unsigned long		rx_data_drops;
@@ -2051,9 +2056,18 @@ struct rf_finetune_var {
 	int             	swq_enable;
 	int             	swq_dbg;
 	int					swq_aggnum;
+	int					swqturboaggnum;
+	int					swqmaxturbotime;
 	int					timeout_thd;
 	int					timeout_thd2;
 	int					timeout_thd3;
+	unsigned int 		tri_time1;
+	unsigned int 		tri_time2;
+	unsigned int 		tri_time3;
+	unsigned int 		tri_time4;
+	unsigned int 		tri_time5;
+	unsigned int 		tri_time6;
+	unsigned int 		tri_time7;
 #endif
 
 	unsigned int		amsdu_th;
@@ -2325,6 +2339,15 @@ struct reorder_ctrl_timer {
 	unsigned int		timeout;
 };
 
+#ifdef SW_TX_QUEUE
+struct sw_tx_queue_timer {
+	struct rtl8192cd_priv	*priv;
+	struct stat_info	*pstat;
+	unsigned char		qnum;
+	UINT32      		timeout;
+};
+#endif
+
 #ifdef RTK_QUE
 struct ring_que {
 	int qlen;
@@ -3209,12 +3232,13 @@ struct priv_shared_info {
 	unsigned int			IQK_total_cnt;
 	unsigned int			IQK_fail_cnt;
 	unsigned char			PhyVersion;
+
+	int		    	txop_decision;    
 #ifdef SW_TX_QUEUE
 	unsigned char   record_mac[6];
 	int             record_qnum;
 	int             swq_txmac_chg;
 	int             swq_en;
-	int		    	swq_decision;
 	unsigned short  record_aid;
 	unsigned long   swqen_keeptime;
 #ifdef SW_TX_QUEUE_SMALL_PACKET_CHECK
@@ -3504,6 +3528,25 @@ struct priv_shared_info {
 	struct reorder_ctrl_timer	amsdu_timer[64];
 	unsigned short				amsdu_timer_head;
 	unsigned short				amsdu_timer_tail;
+#ifdef SW_TX_QUEUE
+	struct sw_tx_queue_timer    swq_timer[SWQ_TIMER_NUM];
+	unsigned short              swq_timer_head;
+	unsigned short              swq_timer_tail;
+    UINT32                      swq_last_tsf;    
+	UINT32                      swq_current_timeout;
+	struct timer_list           swq_sw_timer;    
+	unsigned char               swq_use_hw_timer;    
+    unsigned char				swq_numActiveSTA;
+    unsigned long				swq_turbo_time;
+
+    int						    has_triggered_sw_tx_Q_tasklet; 
+    #ifndef __ECOS
+    struct tasklet_struct	    swq_tasklet;
+    #endif
+#ifdef SW_TXQ_RSVD_DESC
+    unsigned int		swq_skb_queue_cnt[4];	// BK/BE/VI/VO 
+#endif
+#endif
 
 	// ht associated client statistic
 #ifdef WIFI_WMM
@@ -3716,6 +3759,7 @@ typedef struct guestmac {
 #endif
 
 
+
 typedef struct rtl8192cd_priv {
 #if defined(__ECOS) && defined(CONFIG_SDIO_HCI)
 	wifi_link_status_cb_func_t	*link_status_cb_func; // for client mode
diff --git a/driver/rtl8192cd/8192cd_cfg.h b/driver/rtl8192cd/8192cd_cfg.h
index 0d0b221..418bb87 100755
--- a/driver/rtl8192cd/8192cd_cfg.h
+++ b/driver/rtl8192cd/8192cd_cfg.h
@@ -2363,6 +2363,15 @@
 #define RC_ENTRY_NUM	128
 #define AMSDU_TIMER_NUM	64
 #define AMPDU_TIMER_NUM	64
+#define SWQ_TIMER_NUM	(NUM_STAT*4)
+#define SWQ_HWTIMER_TOLERANCE	500 // us
+#define SWQ_HWTIMER_MINIMUN	1000 // us
+#define SWQ_HWTIMER_MAXIMUN	500000 // us
+#define SWQ_HWTIMER_DELAY	34 // us
+#define SWQ_TIMEOUT_THD  300 // ms
+#define SWQ_TIMEOUT_THD_LOWER  3 // count
+
+
 
 #define ROAMING_DECISION_PERIOD_INFRA	5
 #define ROAMING_DECISION_PERIOD_ADHOC	10
diff --git a/driver/rtl8192cd/8192cd_headers.h b/driver/rtl8192cd/8192cd_headers.h
index cc22167..4863164 100755
--- a/driver/rtl8192cd/8192cd_headers.h
+++ b/driver/rtl8192cd/8192cd_headers.h
@@ -93,8 +93,8 @@ extern unsigned int _HS2_debug_warn;	/* warn flag */
 #define HS2_DEBUG_INFO(fmt, args...)
 #endif
 
-//#define PMFDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
-#define PMFDEBUG(fmt, args...)
+#define PMFDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
+//#define PMFDEBUG(fmt, args...)
 #define EDEBUG(fmt, args...) {}
 //#define SDEBUG(fmt, args...) panic_printk("[%s %d]"fmt,__FUNCTION__,__LINE__,## args)
 #define SDEBUG(fmt, args...) { }
@@ -126,6 +126,13 @@ extern unsigned int _HS2_debug_warn;	/* warn flag */
 #define EXTERN
 #endif
 
+#ifdef SW_TX_QUEUE
+EXTERN void turbo_swq_setting(struct rtl8192cd_priv *priv);
+EXTERN void adjust_swq_setting(struct rtl8192cd_priv *priv, struct stat_info *pstat, int i, int mode);
+EXTERN void init_STA_SWQAggNum(struct rtl8192cd_priv *priv);
+#endif
+
+
 /*cfg p2p cfg p2p*/
 EXTERN int rtk_p2p_is_enabled(struct rtl8192cd_priv *priv);
 EXTERN u8* rtk_get_ie_with_oui(u8 *in_ie, int in_len, u8 ie_to_search, u8* oui_input ,int oui_len, int *report_ielen);
@@ -431,9 +438,12 @@ EXTERN __MIPS16 __IRAM_IN_865X void assign_wlanseq(struct rtl8192cd_hw *phw, uns
 	, unsigned char is_11s
 #endif
 	);
-#if 0
-EXTERN void signin_txdesc(struct rtl8190_priv *priv, struct tx_insn* txcfg);
+
+#ifdef SW_TX_QUEUE
+EXTERN void rtl8192cd_swq_timeout(unsigned long task_priv);
+EXTERN void rtl8192cd_swq_deltimer(struct rtl8192cd_priv *priv, struct stat_info* pstat, unsigned char qnum);
 #endif
+
 EXTERN int rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev);
 #ifdef SUPPORT_TX_MCAST2UNI
 EXTERN int rtl8192cd_start_xmit_noM2U(struct sk_buff *skb, struct net_device *dev);
@@ -869,7 +879,7 @@ EXTERN void flush_rx_queue(struct rtl8192cd_priv *priv);
 #define EXTERN
 #endif
 #ifdef CONFIG_WLAN_HAL
-EXTERN BOOLEAN compareAvailableTXBD(struct rtl8192cd_priv * priv, unsigned int num, unsigned int qNum, int compareFlag);
+EXTERN BOOLEAN compareAvailableTXBD(struct rtl8192cd_priv * priv, unsigned int num, unsigned int qNum, int compareFlag, BOOLEAN bUrgent);
 #endif
 EXTERN void check_chipID_MIMO(struct rtl8192cd_priv *priv);
 #ifdef EN_EFUSE
diff --git a/driver/rtl8192cd/8192cd_hw.c b/driver/rtl8192cd/8192cd_hw.c
index 279e256..3b51253 100755
--- a/driver/rtl8192cd/8192cd_hw.c
+++ b/driver/rtl8192cd/8192cd_hw.c
@@ -12779,6 +12779,9 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 			GET_HAL_INTERFACE(priv)->InitIMRHandler(priv, RT_OP_MODE_IBSS);
 		}
 
+#ifdef SW_TX_QUEUE
+		GET_HAL_INTERFACE(priv)->AddInterruptMaskHandler(priv, HAL_INT_TYPE_GTIMER4);
+#endif
 		// TODO: Filen, no need to sync !?
 		priv->pshare->InterruptMask = _GET_HAL_DATA(priv)->IntMask[0];
 		priv->pshare->InterruptMask = _GET_HAL_DATA(priv)->IntMask[1];
@@ -23211,7 +23214,8 @@ compareAvailableTXBD(
 	struct rtl8192cd_priv   *priv,
 	unsigned int            num,
 	unsigned int            qNum,
-	int                     compareFlag
+	int                     compareFlag,
+	BOOLEAN		bUrgent
 )
 {
 	PHCI_TX_DMA_MANAGER_88XX    ptx_dma = (PHCI_TX_DMA_MANAGER_88XX)(_GET_HAL_DATA(priv)->PTxDMA88XX);
@@ -23231,12 +23235,26 @@ compareAvailableTXBD(
 			return FALSE;
 		}
 	} else if (compareFlag == 2) {
-		if (ptx_dma->tx_queue[halQnum].avail_txbd_num < num)  {
-			RESTORE_INT(avail_txbd_flag);
-			return TRUE;
+		if (bUrgent) {
+			if (ptx_dma->tx_queue[halQnum].avail_txbd_num < num)  {
+				RESTORE_INT(avail_txbd_flag);
+				return TRUE;
+			} else {
+				RESTORE_INT(avail_txbd_flag);
+				return FALSE;
+			}
 		} else {
-			RESTORE_INT(avail_txbd_flag);
-			return FALSE;
+			// reserve 32 tx desc for urgent
+			if (ptx_dma->tx_queue[halQnum].avail_txbd_num < 32) {
+				RESTORE_INT(avail_txbd_flag);
+				return TRUE;
+			} else if ((ptx_dma->tx_queue[halQnum].avail_txbd_num - 32) < num)  {
+				RESTORE_INT(avail_txbd_flag);
+				return TRUE;
+			} else {
+				RESTORE_INT(avail_txbd_flag);
+				return FALSE;
+			}
 		}
 	} else {
 		printk("%s(%d): Error setting !!! \n", __FUNCTION__, __LINE__);
diff --git a/driver/rtl8192cd/8192cd_ioctl.c b/driver/rtl8192cd/8192cd_ioctl.c
index d967a71..3870c95 100755
--- a/driver/rtl8192cd/8192cd_ioctl.c
+++ b/driver/rtl8192cd/8192cd_ioctl.c
@@ -1668,12 +1668,31 @@ static struct iwpriv_arg mib_table[] = {
 	{"swql",          RFFT_T, _OFFSET_RFFT(swq_dis_lowthd), _SIZE_RFFT(swq_dis_lowthd), 80},
 	{"swqen",         RFFT_T, _OFFSET_RFFT(swq_enable), _SIZE_RFFT(swq_enable), 1},
 	{"swqdbg",        RFFT_T, _OFFSET_RFFT(swq_dbg), _SIZE_RFFT(swq_dbg), 0},
-
+#ifdef NOT_RTK_BSP
+	{"swqaggnum",		RFFT_T, _OFFSET_RFFT(swq_aggnum), _SIZE_RFFT(swq_aggnum), 32},
+#else
 	{"swqaggnum",		RFFT_T, _OFFSET_RFFT(swq_aggnum), _SIZE_RFFT(swq_aggnum), 8},
+#endif
+	{"swqturboaggnum",		RFFT_T, _OFFSET_RFFT(swqturboaggnum), _SIZE_RFFT(swqturboaggnum), 16},
+	{"swqmaxturbotime",		RFFT_T, _OFFSET_RFFT(swqmaxturbotime), _SIZE_RFFT(swqmaxturbotime), 1},
 
 	{"thd1",			RFFT_T, _OFFSET_RFFT(timeout_thd), _SIZE_RFFT(timeout_thd), 60},
 	{"thd2",            RFFT_T, _OFFSET_RFFT(timeout_thd2), _SIZE_RFFT(timeout_thd2), 150},
 	{"thd3",		  	RFFT_T, _OFFSET_RFFT(timeout_thd3), _SIZE_RFFT(timeout_thd3), 300},
+	{"tri_time1",		RFFT_T, _OFFSET_RFFT(tri_time1), _SIZE_RFFT(tri_time1), 1},
+	{"tri_time2",		RFFT_T, _OFFSET_RFFT(tri_time2), _SIZE_RFFT(tri_time2), 6},
+	{"tri_time3",		RFFT_T, _OFFSET_RFFT(tri_time3), _SIZE_RFFT(tri_time3), 10},
+#ifdef NOT_RTK_BSP
+	{"tri_time4",		RFFT_T, _OFFSET_RFFT(tri_time4), _SIZE_RFFT(tri_time4), 15},
+	{"tri_time5",		RFFT_T, _OFFSET_RFFT(tri_time5), _SIZE_RFFT(tri_time5), 20},
+	{"tri_time6",		RFFT_T, _OFFSET_RFFT(tri_time6), _SIZE_RFFT(tri_time6), 20},
+	{"tri_time7",		RFFT_T, _OFFSET_RFFT(tri_time7), _SIZE_RFFT(tri_time7), 20},
+#else
+	{"tri_time4",		RFFT_T, _OFFSET_RFFT(tri_time4), _SIZE_RFFT(tri_time4), 20},
+	{"tri_time5",		RFFT_T, _OFFSET_RFFT(tri_time5), _SIZE_RFFT(tri_time5), 25},
+	{"tri_time6",		RFFT_T, _OFFSET_RFFT(tri_time6), _SIZE_RFFT(tri_time6), 30},
+	{"tri_time7",		RFFT_T, _OFFSET_RFFT(tri_time7), _SIZE_RFFT(tri_time7), 1},
+#endif
 #endif
 
 	{"amsdu_th",        RFFT_T, _OFFSET_RFFT(amsdu_th), _SIZE_RFFT(amsdu_th), 400},
@@ -3391,9 +3410,11 @@ static int read_reg(struct rtl8192cd_priv *priv, unsigned char *data)
 		}
 		panic_printk("\nread word reg %x=0x%04x\n", offset, w_val);
 		len = 2;
+
 #ifdef _LITTLE_ENDIAN_
-		w_val = ___constant_swab16(w_val);
+		 w_val = ___constant_swab16(w_val);
 #endif
+
 		memcpy(org_ptr, (char *)&w_val, len);
 		break;
 	case 3:
@@ -3409,9 +3430,11 @@ static int read_reg(struct rtl8192cd_priv *priv, unsigned char *data)
 		}
 		panic_printk("\nread dword reg %x=0x%08lx\n", offset, dw_val);
 		len = 4;
+
 #ifdef _LITTLE_ENDIAN_
 		dw_val = ___constant_swab32(dw_val);
 #endif
+
 		memcpy(org_ptr, (char *)&dw_val, len);
 		break;
 	}
@@ -3666,9 +3689,13 @@ static int read_rf_reg(struct rtl8192cd_priv *priv, unsigned char *data)
 		offset = (unsigned char)_atoi((char *)arg, 16);
 		val = PHY_QueryRFReg(priv, path, offset, bMask20Bits, 1);
 		panic_printk("\nread RF %d reg %02x=0x%08x\n", path, offset, val);
+
+
+
 #ifdef _LITTLE_ENDIAN_
 		val = ___constant_swab32(val);
 #endif
+
 		memcpy(data, (char *)&val, 4);
 		return 4;
 	}
diff --git a/driver/rtl8192cd/8192cd_osdep.c b/driver/rtl8192cd/8192cd_osdep.c
index 87769c8..7af436e 100644
--- a/driver/rtl8192cd/8192cd_osdep.c
+++ b/driver/rtl8192cd/8192cd_osdep.c
@@ -1436,6 +1436,7 @@ __inline__ static int __rtl_wlan_interrupt(void *dev_instance)
     BOOLEAN casePwrInt0, casePwrInt1, casePwrInt2, casePwrInt3 , casePwrInt4;    
 #endif
 	BOOLEAN caseC2HIsr;
+	BOOLEAN caseGTimer4Int;
 
 #if 1   //Filen: temp
     static unsigned int caseRxRDUCnt=0, caseRxOKCnt=0;
@@ -1475,6 +1476,7 @@ int_retry_process:
         caseRxRDU           = FALSE;
         caseRxOK            = FALSE;
         caseRxFOVW          = FALSE;
+        caseGTimer4Int      = FALSE;
 
 #if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
         caseTimer2 = FALSE;
@@ -1659,6 +1661,32 @@ int_retry_process:
             }
         }    
 #endif
+    // 6.) SW TX QUEUE
+    #ifdef SW_TX_QUEUE
+    caseGTimer4Int = GET_HAL_INTERFACE(priv)->GetInterruptHandler(priv, HAL_INT_TYPE_GTIMER4);
+    if(caseGTimer4Int == TRUE) {
+        {
+
+            #ifdef SW_TX_QUEUE
+            if(priv->pshare->swq_use_hw_timer) {
+                if (!priv->pshare->has_triggered_sw_tx_Q_tasklet) {
+                    priv->pshare->has_triggered_sw_tx_Q_tasklet = 1;
+                    #ifdef __ECOS                
+                    priv->pshare->call_dsr = 1; /*by DSR(ECOS) at 8192cd_ecos.c  / tasklet(Linux)*/ 
+                    #else
+                    tasklet_schedule(&priv->pshare->swq_tasklet);
+                    #endif
+                }
+            }
+            #endif //SW_TX_QUEUE
+
+        }
+
+
+    }
+    #endif //defined(SW_TX_QUEUE)
+
+    
 	if ((retry_cnt++) <= RTL_WLAN_INT_RETRY_CNT_MAX ) {
 		if (GET_HAL_INTERFACE(priv)->InterruptRecognizedHandler(priv, NULL, 0)) {
 			PHAL_DATA_TYPE              pHalData = _GET_HAL_DATA(priv);
@@ -1747,6 +1775,7 @@ __inline__ static int __rtl8192cd_interrupt(void *dev_instance)
 	unsigned int status_bak, status_ext_bak;
 	unsigned int caseBcnInt, caseBcnStatusOK, caseBcnStatusER, caseBcnDmaOK=0;
 	unsigned int caseRxStatus, caseRxRDU;
+	unsigned int caseGTimer4Int;
 	
 	#if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
 	unsigned int caseTimer2;
@@ -1835,6 +1864,7 @@ retry_process:
 	
 	caseBcnInt = caseBcnStatusOK = caseBcnStatusER = caseBcnDmaOK = 0;
 	caseRxStatus = caseRxRDU = 0;
+	caseGTimer4Int = 0;
 	
 	#if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
 	caseTimer2 = 0;
@@ -1880,6 +1910,11 @@ retry_process:
 			caseBcnInt = 1;
 		}
 
+#ifdef SW_TX_QUEUE
+		if(status & HIMR_88E_GTINT4) {
+			caseGTimer4Int = 1;
+		}
+#endif
 		if (status & HIMR_88E_TBDOK)
 			caseBcnStatusOK = 1;
 
@@ -1911,6 +1946,11 @@ retry_process:
 			caseBcnInt = 1;
 		}
 	
+#ifdef SW_TX_QUEUE
+		if(status & IMR_GTINT4_8812) {
+			caseGTimer4Int = 1;
+		}
+#endif
 		if (status & HIMR_92E_TBDOK)
 			caseBcnStatusOK = 1;
 	
@@ -2108,6 +2148,25 @@ retry_process:
 	}
 #endif
 
+#ifdef SW_TX_QUEUE
+    if(caseGTimer4Int)
+    {
+        {
+#ifdef SW_TX_QUEUE   
+            if(priv->pshare->swq_use_hw_timer) {
+                if (!priv->pshare->has_triggered_sw_tx_Q_tasklet) {
+                    priv->pshare->has_triggered_sw_tx_Q_tasklet = 1;
+                    #ifdef __ECOS                
+                    priv->pshare->call_dsr = 1; /*by DSR(ECOS) at 8192cd_ecos.c  / tasklet(Linux)*/ 
+                    #else
+                    tasklet_schedule(&priv->pshare->swq_tasklet);
+                    #endif
+                }
+            }            
+#endif            
+        }
+    }
+#endif //defined(SW_TX_QUEUE)
 
 #ifdef P2P_SUPPORT
 	if( rtk_p2p_is_enabled(priv) &&	(rtk_p2p_chk_role(priv,P2P_CLIENT))) {
@@ -3238,6 +3297,24 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
             priv->pshare->fw_free_space--;
         }
 
+#ifdef SW_TX_QUEUE
+        #if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+        if(GET_CHIP_VER(priv) == VERSION_8192C || GET_CHIP_VER(priv) == VERSION_8192D ||
+           GET_CHIP_VER(priv) == VERSION_8188C || GET_CHIP_VER(priv) == VERSION_8188E) {
+            priv->pshare->swq_use_hw_timer = 0;
+    		init_timer(&priv->pshare->swq_sw_timer);
+    		priv->pshare->swq_sw_timer.data = (unsigned long) priv;
+    		priv->pshare->swq_sw_timer.function = rtl8192cd_swq_timeout;            
+        }
+        else
+        #endif
+        {
+            priv->pshare->swq_use_hw_timer = 1;           
+            #ifndef __ECOS
+            tasklet_init(&priv->pshare->swq_tasklet, rtl8192cd_swq_timeout, (unsigned long)priv);
+            #endif
+        }
+#endif
 	}
 
 	//
@@ -4478,6 +4555,17 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 		}
 #endif
 
+#ifdef SW_TX_QUEUE
+        if(priv->pshare->swq_use_hw_timer) {
+            #ifndef __ECOS
+            tasklet_kill(&priv->pshare->swq_tasklet);
+            #endif
+        }
+        else {
+            if (timer_pending(&priv->pshare->swq_sw_timer))
+                del_timer_sync(&priv->pshare->swq_sw_timer);
+        }
+#endif    
 	}
 
 #ifdef RTK_NL80211 // wrt-adhoc
diff --git a/driver/rtl8192cd/8192cd_proc.c b/driver/rtl8192cd/8192cd_proc.c
index eea2f06..6bb89c1 100755
--- a/driver/rtl8192cd/8192cd_proc.c
+++ b/driver/rtl8192cd/8192cd_proc.c
@@ -4871,7 +4871,7 @@ static int dump_one_sta_dbginfo(int num, struct stat_info *pstat, char *buf, cha
 #ifdef SW_TX_QUEUE
 	PRINT_SINGL_ARG("    bk aggnum:   ", pstat->swq.q_aggnum[BK_QUEUE], "%d");
 	PRINT_SINGL_ARG("    be aggnum:   ", pstat->swq.q_aggnum[BE_QUEUE], "%d");
-	PRINT_SINGL_ARG("	 be qlen:   ", skb_queue_len(&pstat->swq.be_queue), "%d");
+	PRINT_SINGL_ARG("	 be qlen:   ", skb_queue_len(&pstat->swq.swq_queue[BE_QUEUE]), "%d");
 	PRINT_SINGL_ARG("    vi aggnum:   ", pstat->swq.q_aggnum[VI_QUEUE], "%d");
 	PRINT_SINGL_ARG("    vo aggnum:   ", pstat->swq.q_aggnum[VO_QUEUE], "%d");
 	PRINT_SINGL_ARG("    bk backtime:   ", pstat->swq.q_aggnumIncSlow[BK_QUEUE], "%d");
@@ -4921,6 +4921,10 @@ static int rtl8192cd_proc_sta_dbginfo(char *buf, char **start, off_t offset,
 	CHECK_LEN;
 #endif
 
+#ifdef SW_TX_QUEUE
+	PRINT_SINGL_ARG("    swq_numActiveSTA:   ", priv->pshare->swq_numActiveSTA, "%d");
+#endif	
+
 	phead = &priv->asoc_list;
 	if (!netif_running(dev) || list_empty(phead))
 		goto _ret;
@@ -5188,6 +5192,7 @@ static int rtl8192cd_proc_stats(char *buf, char **start, off_t offset,
 #endif
 #ifdef SW_TX_QUEUE
 	PRINT_SINGL_ARG("    swq enable:    ", priv->pshare->swq_en, "%d");
+    PRINT_SINGL_ARG("    swq hw timer:   ", priv->pshare->swq_use_hw_timer, "%d");    
 #endif
 
 #ifdef CONFIG_WLAN_HAL
diff --git a/driver/rtl8192cd/8192cd_rx.c b/driver/rtl8192cd/8192cd_rx.c
index 1eb2fbb..dd037fd 100755
--- a/driver/rtl8192cd/8192cd_rx.c
+++ b/driver/rtl8192cd/8192cd_rx.c
@@ -7304,6 +7304,10 @@ check_privacy:
 		}
 		else
 		{
+			if (OPMODE & WIFI_AP_STATE){
+				issue_deauth(priv, sa, _RSON_UNSPECIFIED_);
+				DEBUG_ERR("sa:%X%X%X%X%X%X\n", sa[0], sa[1], sa[2], sa[3],sa[4], sa[5]);
+			}
 			DEBUG_ERR("RX DROP: encrypted packet but no key in sta or wrong enc type!\n");
 			goto free_skb_in_defrag;
 		}
diff --git a/driver/rtl8192cd/8192cd_rx.h b/driver/rtl8192cd/8192cd_rx.h
index 5347aaa..cf5bba1 100755
--- a/driver/rtl8192cd/8192cd_rx.h
+++ b/driver/rtl8192cd/8192cd_rx.h
@@ -274,6 +274,14 @@ static __inline__ void update_sta_rssi(struct rtl8192cd_priv *priv,
 			//}
 #endif
 
+#if defined(MULTI_STA_REFINE) && defined(TX_SHORTCUT) && defined(SW_TX_QUEUE)
+			if( ((GET_CHIP_VER(priv) == VERSION_8192E) || (GET_CHIP_VER(priv)==VERSION_8812E)) ) {
+				if(((pstat->rssi <30 && rssi_old >=30)||(pstat->rssi >=30 && rssi_old <30)) && (priv->pshare->swq_numActiveSTA > LOWAGGRESTA))
+					clearTxShortCutBufSize(priv, pstat);
+			}
+#endif
+
+
 			if (pstat->highest_rx_rate < pstat->rx_rate)
 				pstat->highest_rx_rate = pstat->rx_rate;
 		}
diff --git a/driver/rtl8192cd/8192cd_sme.c b/driver/rtl8192cd/8192cd_sme.c
index d601b34..de033b6 100644
--- a/driver/rtl8192cd/8192cd_sme.c
+++ b/driver/rtl8192cd/8192cd_sme.c
@@ -1956,20 +1956,25 @@ if(!IS_OUTSRC_CHIP(priv))
             SMP_LOCK_XMIT(flags);  
             for (i=BK_QUEUE;i<=VO_QUEUE;i++) 
             {				
+                if(priv->pshare->swq_use_hw_timer) {
+                    if (priv->pshare->swq_en && pstat->swq.swq_en[i] && (pstat->tx_avarage > 25000) && (pstat->ht_cap_len)) {                        
+                        adjust_swq_setting(priv, pstat, i, CHECK_INC_AGGN);
+                    }                             
+                }
+                else {
                 int q_aggnumIncSlow = (priv->assoc_num > 1) ? (2+pstat->swq.q_aggnumIncSlow[i]) : (1+pstat->swq.q_aggnumIncSlow[i]);
-                //int q_aggnumIncSlow =  (1+pstat->swq.q_aggnumIncSlow[i]);				
-#if 1//def SW_TX_QUEUE_SMALL_PACKET_CHECK
-                if ((priv->pshare->swq_en == 0) /*|| (((priv->ext_stats.tx_avarage>>17) + (priv->ext_stats.rx_avarage>>17)) < 20)*/) { // disable check for small udp packet(88B) test with veriwave tool
-#else
-                if ((priv->pshare->swq_en == 0) || (((priv->ext_stats.tx_avarage>>17) + (priv->ext_stats.rx_avarage>>17)) < 20)) {
-#endif
-                    //pstat->swq.q_aggnum[i] = priv->pshare->rf_ft_var.swq_aggnum;	
+                    if ((priv->pshare->swq_en == 0) /*|| (((priv->ext_stats.tx_avarage>>17) + (priv->ext_stats.rx_avarage>>17)) < 20)*/) { // disable check for small udp packet(88B) test with veriwave tool
+                        pstat->swq.q_aggnumIncSlow[i] = 0;
+                    }
+                    else if (((priv->up_time % q_aggnumIncSlow) == 0) && 
+                            ((priv->pshare->swqen_keeptime != 0) && 
+                            (priv->up_time > priv->pshare->swqen_keeptime+3)) && 
+                            (pstat->tx_avarage > 25000) && (pstat->ht_cap_len)) {
+                        adjust_swq_setting(priv, pstat, i, CHECK_INC_AGGN);
+                    }             
 
-                    pstat->swq.q_aggnumIncSlow[i] = 0;
-                }
-                else if (((priv->up_time % q_aggnumIncSlow) == 0) && ((priv->pshare->swqen_keeptime != 0) && (priv->up_time > priv->pshare->swqen_keeptime+3)) && (pstat->tx_avarage > 25000) && (pstat->ht_cap_len)) {
-                    adjust_swq_setting(priv, pstat, i, CHECK_INC_AGGN);
                 }
+
                 /*clear used*/
                 pstat->swq.q_used[i] = 0;
                 pstat->swq.q_TOCount[i] = 0;
@@ -5282,8 +5287,8 @@ hs_break:
 #else
 	priv->pshare->swq_boost_delay = 0;
 #endif
+#endif
 
-#else
 	//for debug 
 	//if (priv->pshare->rf_ft_var.swq_dbg)
 	//	printk("sw cnt:%d:%d,0x%x\n", priv->swq_txmac_chg,priv->swq_en, RTL_R32(EDCA_BE_PARA));
@@ -5291,7 +5296,6 @@ hs_break:
 	if (IS_ROOT_INTERFACE(priv))
         priv->pshare->swq_txmac_chg = 0;
 #endif		
-#endif
 
 #if defined(CLIENT_MODE) && defined(WIFI_11N_2040_COEXIST)
 //#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
@@ -6124,7 +6128,7 @@ static int isCorrectRobustFrame(struct rtl8192cd_priv *priv, struct rx_frinfo *p
 							
 			if (pfrinfo->pktlen <= pfrinfo->hdr_len+16)
 				return MGMT_FRAME_MIC_ERR;
-
+			
 			memcpy(mic,pframe + pfrinfo->pktlen - 8, 8);			
 			aesccmp_decrypt(priv, pfrinfo, 1);			
 			
diff --git a/driver/rtl8192cd/8192cd_tx.c b/driver/rtl8192cd/8192cd_tx.c
index f101832..7a640d2 100755
--- a/driver/rtl8192cd/8192cd_tx.c
+++ b/driver/rtl8192cd/8192cd_tx.c
@@ -1224,10 +1224,10 @@ int rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev)
  	}
 
 #ifdef SMP_LOAD_BALANCE_SUPPORT
-	if (compareAvailableTXBD(priv, (NUM_TX_DESC/10), VI_QUEUE, 2) ||
-		compareAvailableTXBD(priv, (NUM_TX_DESC/10), VO_QUEUE, 2) ||
-		compareAvailableTXBD(priv, (NUM_TX_DESC/10), BE_QUEUE, 2) ||
-		compareAvailableTXBD(priv, (NUM_TX_DESC/10), BK_QUEUE, 2)) {
+	if (compareAvailableTXBD(priv, (NUM_TX_DESC/10), VI_QUEUE, 2, FALSE) ||
+		compareAvailableTXBD(priv, (NUM_TX_DESC/10), VO_QUEUE, 2, FALSE) ||
+		compareAvailableTXBD(priv, (NUM_TX_DESC/10), BE_QUEUE, 2, FALSE) ||
+		compareAvailableTXBD(priv, (NUM_TX_DESC/10), BK_QUEUE, 2, FALSE)) {
 		if (skb_queue_len(&priv->pshare->skb_xmit_queue) >= NUM_TX_DESC/10) {
 			dev_kfree_skb_any(skb);
 			return 0; 
@@ -1338,7 +1338,7 @@ static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, stru
 			if (skb_queue_len(&pstat->amsdu_tx_que[tid]) > 0) {
                 if (
 #ifdef  CONFIG_WLAN_HAL
-                    (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 10, q_num, 2)) :
+                    (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 10, q_num, 2, FALSE)) :
 #endif		
                     (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < 10) ) {
 
@@ -1353,7 +1353,7 @@ static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, stru
 
                     if (
 #ifdef  CONFIG_WLAN_HAL
-                        (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 10, q_num, 2)) :
+                        (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 10, q_num, 2, FALSE)) :
 #endif		
                         (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < 10) ) {
 
@@ -1386,7 +1386,7 @@ static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, stru
 				((total_len + pstat->amsdu_tx_que[tid].next->len + sizeof(struct llc_snap) + 3) > max_size) ||
 				(
 #ifdef CONFIG_WLAN_HAL
-                (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 1, q_num, 2)) : 
+                (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, 1, q_num, 2, FALSE)) : 
 #endif
 				(total_num >= (space - 4)) )|| // 1 for header, 1 for ICV when sw encrypt, 2 for spare 
 				(!pstat->is_realtek_sta && (total_num >= (priv->pmib->dot11nConfigEntry.dot11nAMSDUSendNum-1)))
@@ -1622,7 +1622,7 @@ void amsdu_timeout(struct rtl8192cd_priv *priv, unsigned int current_time)
 
 #ifdef  CONFIG_WLAN_HAL
     if (IS_HAL_CHIP(priv)) {
-        if (compareAvailableTXBD(priv, 10, q_num, 2))
+        if (compareAvailableTXBD(priv, 10, q_num, 2, FALSE))
             return RET_AGGRE_DESC_FULL;
     } else 
 #endif
@@ -1768,7 +1768,7 @@ static inline void check_tx_queue(struct rtl8192cd_priv *priv)
 		}
         if (
 #ifdef  CONFIG_WLAN_HAL
-            (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/4), BE_QUEUE, 2)) :
+            (IS_HAL_CHIP(priv)) ? (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/4), BE_QUEUE, 2, FALSE)) :
 #endif		
 			(CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < (CURRENT_NUM_TX_DESC/4)) 
 		)	
@@ -2090,7 +2090,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 				if (priv->stop_tx_mcast2uni  == 1) {
 #ifdef CONFIG_WLAN_HAL
                         if(IS_HAL_CHIP(priv)) {
-                        	if(compareAvailableTXBD(priv, ((CURRENT_NUM_TX_DESC*1)/4), q_num, 1)) 
+                        	if(compareAvailableTXBD(priv, ((CURRENT_NUM_TX_DESC*1)/4), q_num, 1, FALSE)) 
 								priv->stop_tx_mcast2uni = 0;
                         } else if(CONFIG_WLAN_NOT_HAL_EXIST)
 #endif
@@ -2117,7 +2117,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 			} else {
 #ifdef CONFIG_WLAN_HAL
                 if(IS_HAL_CHIP(priv)) {
-					if(compareAvailableTXBD(priv, 20, q_num, 2)) {
+					if(compareAvailableTXBD(priv, 20, q_num, 2, FALSE)) {
 						asoc_list_unref(priv, pstat);
 						#ifdef __ECOS
 						#else
@@ -3169,7 +3169,21 @@ rtl88XX_fill_fwinfo(
 #endif
                 }
 				pdesc_data->maxAggNum = txcfg->pstat->maxAggNum >> 1;
-            }
+ #ifdef MULTI_STA_REFINE 					
+				if(GET_CHIP_VER(priv) == VERSION_8192E) {
+					if (txcfg->tx_rate < STA_TX_LOWRATE && pdesc_data->maxAggNum>2)
+						pdesc_data->maxAggNum = 2;
+				}		
+#ifdef SW_TX_QUEUE
+				if (priv->pshare->swq_numActiveSTA > LOWAGGRESTA && pdesc_data->maxAggNum>4) {
+					if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
+						pdesc_data->maxAggNum = 8;			// max agg# 16	
+					else
+						pdesc_data->maxAggNum = 4;			// max agg# 8
+				}
+#endif						
+#endif	
+           }
             //set Break
             if((txcfg->q_num >=1 && txcfg->q_num <=4)){
                 if((txcfg->pstat != priv->pshare->CurPstat[txcfg->q_num-1])) {
@@ -7263,514 +7277,599 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat, str
 #else
 int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info	*pstat);
 #endif
+#endif
+
 
 
-void rtl8192cd_beq_timer(unsigned long task_priv)
+#if defined(SW_TX_QUEUE)
+__inline__ static int rtl8192cd_swq_bdfull(struct rtl8192cd_priv *priv, struct stat_info *pstat,  unsigned char qnum)
 {
-    struct stat_info        *pstat = (struct stat_info *)task_priv;
-    struct sk_buff *skb = NULL;
-	struct rtl8192cd_priv *priv = NULL;
-	unsigned long x = 0, bdfull=0, qnum = BE_QUEUE;
-	struct aid_obj *aidobj;	
-	int	*tx_head=NULL, *tx_tail=NULL;		
+    int *tx_head=NULL, *tx_tail=NULL;
 
-	aidobj = container_of(pstat, struct aid_obj, station);
-	priv = aidobj->priv;
+#ifdef CONFIG_WLAN_HAL	 	 
+    if(IS_HAL_CHIP(priv))    {
+        if(compareAvailableTXBD(priv, 4, qnum, 2, FALSE))
+            return 1;
+    } else if(CONFIG_WLAN_NOT_HAL_EXIST)
+#endif
+    {
+        tx_head = get_txhead_addr(GET_HW(priv), qnum);
+        tx_tail = get_txtail_addr(GET_HW(priv), qnum);
+        if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
+            return 1;
+    }
 
-	if (!(priv->drv_state & DRV_STATE_OPEN)) {
-		return;
-	}	
+    return 0;
+}
+#endif
 
-	SMP_LOCK_XMIT(x);
-	SAVE_INT_AND_CLI(x);	
 
-#ifdef CONFIG_WLAN_HAL
-	if(IS_HAL_CHIP(priv)){
-		if(compareAvailableTXBD(priv, 4, qnum, 2))
-			bdfull = 1;
-   }else if(CONFIG_WLAN_NOT_HAL_EXIST) 
-#endif
-   {
-		tx_head = get_txhead_addr(GET_HW(priv), qnum);
-		tx_tail = get_txtail_addr(GET_HW(priv), qnum);
-		if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
-			bdfull = 1;
-   	}
-	
-    while(1) {
+#ifdef SW_TX_QUEUE
+/* when using hw timer,  the parameter "add_timer_timeout" is TSF time
+     when using sw timer, the parameter "add_timer_timeout" is jiffies time
+*/
+__inline__ static void rtl8192cd_swq_settimer(struct rtl8192cd_priv *priv, UINT32 timer_timeout)
+{
+    UINT32 set_timeout;    
+    UINT32 current_time;
+    unsigned char set_timer = 0;
+
+    if(timer_timeout == 0) {
+        if(priv->pshare->swq_current_timeout) {
+            priv->pshare->swq_current_timeout = 0;
+            if(priv->pshare->swq_use_hw_timer) {                          
+                current_time = RTL_R32(TSFTR1);  
+                if(current_time - priv->pshare->swq_last_tsf < SWQ_HWTIMER_DELAY) {
+                    delay_us(SWQ_HWTIMER_DELAY - (current_time - priv->pshare->swq_last_tsf));
+                }
+                RTL_W32(TC4_CTRL, 0);           
+                priv->pshare->swq_last_tsf = RTL_R32(TSFTR1);
+            }
+            else {      
+                if (timer_pending(&priv->pshare->swq_sw_timer))
+			        del_timer_sync(&priv->pshare->swq_sw_timer);
+            }            
+        }
+    }
+    else {
+        if(priv->pshare->swq_use_hw_timer) {  
+            current_time = RTL_R32(TSFTR1);   
+            set_timeout = current_time + SWQ_HWTIMER_MINIMUN;
+            if(timer_timeout - set_timeout > SWQ_HWTIMER_MAXIMUN) {                
+                timer_timeout = set_timeout;
+                set_timeout = SWQ_HWTIMER_MINIMUN;                
+            }            
+            else {
+                set_timeout = timer_timeout - current_time;
+            }
 
-		if(bdfull)	{		
-			 struct sk_buff_head *pqueue = &pstat->swq.be_queue;
-			 struct timer_list *ptimer;
-			 int aggnum=pstat->swq.q_aggnum[qnum];
-			 ptimer = &pstat->swq.beq_timer;						 
-			
-			if(skb_queue_len(pqueue) <= aggnum*2) 
-			{
-				pstat->swq.q_used[qnum]=1;
-				if (!timer_pending(ptimer))
-				{					
-					ptimer->data = (unsigned long) pstat;
-					ptimer->function = rtl8192cd_beq_timer; //rtl8190_tmp_timer;
-					mod_timer(ptimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(30));
-				}
-				break;
-			}
-		}
+            if(priv->pshare->swq_current_timeout) {
+                if(timer_timeout + SWQ_HWTIMER_TOLERANCE - priv->pshare->swq_current_timeout > SWQ_HWTIMER_MAXIMUN) {                
+                    set_timer = 1;
+                }
+            }
+            else {
+                set_timer = 1;
+            }
 
-		
-    	skb = skb_dequeue(&pstat->swq.be_queue);
+            if(set_timer) {                         
+                if(current_time - priv->pshare->swq_last_tsf < SWQ_HWTIMER_DELAY) {
+                   delay_us(SWQ_HWTIMER_DELAY - (current_time - priv->pshare->swq_last_tsf));
+                }
+                priv->pshare->swq_current_timeout = (timer_timeout == 0?1:timer_timeout);            
+                set_timeout = RTL_MICROSECONDS_TO_GTIMERCOUNTER(set_timeout);                
+                set_timeout = BIT26 | BIT24 | (set_timeout & 0x00FFFFFF);  //TC40INT_EN | TC4EN | TC4Data
+                RTL_W32(TC4_CTRL, set_timeout);           
+                priv->pshare->swq_last_tsf = RTL_R32(TSFTR1);
+            }            
+        }
+        else {
+            if(priv->pshare->swq_current_timeout) {                          
+                if(timer_timeout < priv->pshare->swq_current_timeout) {                
+                    set_timer = 1;
+                }                
+            }
+            else {            
+                set_timer = 1;
+            }
 
-        if (skb == NULL)
-        	break;
+            if(set_timer) {                                
+                priv->pshare->swq_current_timeout = timer_timeout;            
+                mod_timer(&priv->pshare->swq_sw_timer, (unsigned long)timer_timeout);            
+            }            
+        }
+    }
+}
 
-     
 
+/* when using hw timer,  the parameter "add_timer_timeout" is TSF time
+     when using sw timer, the parameter "add_timer_timeout" is jiffies time
+*/
+__inline__ static int rtl8192cd_swq_addtimer(struct rtl8192cd_priv *priv, struct stat_info* pstat, unsigned char qnum, UINT32 add_timer_timeout)
+{
+    unsigned short timer_index = (priv->pshare->swq_timer_head + 1) % SWQ_TIMER_NUM; 
+    if(priv->pshare->swq_timer_tail == timer_index) { /* queue is full */           
+        /* find an empty slot */
+        for(timer_index = 0 ; timer_index < SWQ_TIMER_NUM; timer_index++) {
+            if(timer_index == priv->pshare->swq_timer_tail) {
+                continue;
+            }
+            if(priv->pshare->swq_timer[timer_index].pstat == NULL) {
+                 break;
+            }
+        }
 
-#ifdef TX_EARLY_MODE
-	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
-		get_tx_early_info(priv, pstat, &pstat->swq.be_queue);		
-#endif		
-		
-#if defined(CONFIG_RTK_MESH)
-		__rtl8192cd_start_xmit_out(skb, pstat, NULL);
-#else
-        __rtl8192cd_start_xmit_out(skb, pstat);
-#endif
-		
-		pstat->swq.q_TOCount[BE_QUEUE]++;
+        if(timer_index == SWQ_TIMER_NUM) {
+            printk("%s: %s, swq timer overflow!\n", priv->dev->name, __FUNCTION__);
+            return -1;
+        }
     }
-	if(skb_queue_len(&pstat->swq.be_queue) ==0)
-		pstat->swq.beq_empty = 0;
 
-	RESTORE_INT(x);		
-    SMP_UNLOCK_XMIT(x);
+    priv->pshare->swq_timer_head = timer_index;                 
+    priv->pshare->swq_timer[timer_index].priv = priv;
+    priv->pshare->swq_timer[timer_index].pstat = pstat;
+    priv->pshare->swq_timer[timer_index].qnum = qnum;
+    priv->pshare->swq_timer[timer_index].timeout = add_timer_timeout;
+    pstat->swq.swq_timer_id[qnum] = timer_index + 1;
 
-	if(!bdfull) {
-		SAVE_INT_AND_CLI(x);
-		SMP_LOCK(x);
-		adjust_swq_setting(priv, pstat, BE_QUEUE, CHECK_DEC_AGGN);
-		SMP_UNLOCK(x);
-		RESTORE_INT(x);
-	}
+    return 0;
 }
 
-void rtl8192cd_bkq_timer(unsigned long task_priv)
-{
-	 struct stat_info		 *pstat = (struct stat_info *)task_priv;
-	 struct sk_buff *skb = NULL;
-	 struct rtl8192cd_priv *priv = NULL;
-	 unsigned long x = 0, bdfull=0, qnum = BK_QUEUE;
-	 struct aid_obj *aidobj;
-	 int *tx_head=NULL, *tx_tail=NULL;	 
-
 
-	 aidobj = container_of(pstat, struct aid_obj, station);
-	 priv = aidobj->priv;
-
-	if (!(priv->drv_state & DRV_STATE_OPEN)) {
-		return;
-	}
-	SMP_LOCK_XMIT(x);
-	SAVE_INT_AND_CLI(x);	 
-		 
-#ifdef CONFIG_WLAN_HAL	 
-	 if(IS_HAL_CHIP(priv))	 {
-		 if(compareAvailableTXBD(priv, 4, qnum, 2))
-			 bdfull = 1;
-	}else if(CONFIG_WLAN_NOT_HAL_EXIST) 
-#endif
-	{
-		 tx_head = get_txhead_addr(GET_HW(priv), qnum);
-		 tx_tail = get_txtail_addr(GET_HW(priv), qnum);
-		 if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
-			 bdfull = 1;
-	 }
-
-    while(1) {
-
-		if(bdfull) {	   
-			struct sk_buff_head *pqueue = &pstat->swq.bk_queue;
-			struct timer_list *ptimer;
-			int aggnum=pstat->swq.q_aggnum[qnum];
-			ptimer = &pstat->swq.bkq_timer; 				
-		   
-		   if(skb_queue_len(pqueue) <= aggnum*2) 
-		   {
-			   pstat->swq.q_used[qnum]=1;
-			   if (!timer_pending(ptimer))
-			   {				   
-				   ptimer->data = (unsigned long) pstat;
-				   ptimer->function = rtl8192cd_bkq_timer; //rtl8190_tmp_timer;
-				   mod_timer(ptimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(30));
-			   }
-			   break;
-		   }
-		}		
-		
-    	skb = skb_dequeue(&pstat->swq.bk_queue);
+void rtl8192cd_swq_deltimer(struct rtl8192cd_priv *priv, struct stat_info* pstat, unsigned char qnum)
+{
+    unsigned char set_timer = 0;
+    unsigned short temp_tail;
+    unsigned short timer_index = pstat->swq.swq_timer_id[qnum]-1;
+    UINT32 set_timer_timeout = 0;
+    priv->pshare->swq_timer[timer_index].pstat = NULL;
+    pstat->swq.swq_timer_id[qnum] = 0; 
+
+    /*dequeu dummy slot */    
+     while(priv->pshare->swq_timer_head != priv->pshare->swq_timer_tail) /*check if queue is empty*/
+    {
+        temp_tail = (priv->pshare->swq_timer_tail + 1) % SWQ_TIMER_NUM;
+        if(priv->pshare->swq_timer[temp_tail].pstat != NULL) {
+            break;
+        }            
+        priv->pshare->swq_timer_tail = temp_tail;
+    }
+  
+    if (priv->pshare->swq_timer_head != priv->pshare->swq_timer_tail) // if queue is not empty
+    {
+        temp_tail = priv->pshare->swq_timer_tail;
+        do {            
+            temp_tail = (temp_tail + 1) % SWQ_TIMER_NUM;
+            if(priv->pshare->swq_timer[temp_tail].pstat != NULL) {
+                if(priv->pshare->swq_use_hw_timer) { 
+                    if(priv->pshare->swq_timer[temp_tail].timeout - (priv->pshare->swq_current_timeout + SWQ_HWTIMER_MINIMUN) > SWQ_HWTIMER_MAXIMUN) {
+                        set_timer = 0;
+                        break;
+                    }
+                    else {
+                        if(set_timer == 0) {
+                            set_timer_timeout = priv->pshare->swq_timer[temp_tail].timeout;
+                        }
+                        else {
+                            if(priv->pshare->swq_timer[temp_tail].timeout - set_timer_timeout > SWQ_HWTIMER_MAXIMUN) {
+                                set_timer_timeout = priv->pshare->swq_timer[temp_tail].timeout;
+                            }                     
+                        }
+                        
+                        set_timer = 1;
+                    }
+                }
+                else {
+                    if(priv->pshare->swq_timer[temp_tail].timeout <= priv->pshare->swq_current_timeout) {
+                        set_timer = 0;
+                        break;
+                    }
+                    else {
+                        if(set_timer == 0) {
+                            set_timer_timeout = priv->pshare->swq_timer[temp_tail].timeout;
+                        }
+                        else {
+                            if(priv->pshare->swq_timer[temp_tail].timeout < set_timer_timeout) {
+                                set_timer_timeout = priv->pshare->swq_timer[temp_tail].timeout;
+                            }
+                        }                        
+                        set_timer = 1;
+                    }
 
-        if (skb == NULL)
-        	break;
-	
+                }                
+            }
+        }while(temp_tail != priv->pshare->swq_timer_head);
 
-#ifdef TX_EARLY_MODE
-	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
-		get_tx_early_info(priv, pstat, &pstat->swq.bk_queue);		
-#endif		
-		
-#if defined(CONFIG_RTK_MESH)
-		__rtl8192cd_start_xmit_out(skb, pstat, NULL);
-#else
-        __rtl8192cd_start_xmit_out(skb, pstat);
-#endif
-		
-		pstat->swq.q_TOCount[BK_QUEUE]++;
+        if(set_timer) {
+            rtl8192cd_swq_settimer(priv, 0);
+            rtl8192cd_swq_settimer(priv, set_timer_timeout);   /*need to re-setup timer*/              
+        }
+    }
+    else {
+        rtl8192cd_swq_settimer(priv, 0);   /*disable timer*/
     }
-	if(skb_queue_len(&pstat->swq.bk_queue) ==0)
-	    pstat->swq.bkq_empty = 0;
 
-	RESTORE_INT(x);
-	SMP_UNLOCK_XMIT(x);
-	
-	if(!bdfull) {
-	    SAVE_INT_AND_CLI(x);
-	    SMP_LOCK(x);
-		adjust_swq_setting(priv, pstat, BK_QUEUE, CHECK_DEC_AGGN);
-	    SMP_UNLOCK(x);
-		RESTORE_INT(x);
-	}
 }
 
-void rtl8192cd_viq_timer(unsigned long task_priv)
-{
-	 struct stat_info		 *pstat = (struct stat_info *)task_priv;
-	 struct sk_buff *skb = NULL;
-	 struct rtl8192cd_priv *priv = NULL;
-	 unsigned long x = 0, bdfull=0, qnum = VI_QUEUE;
-	 struct aid_obj *aidobj;
-	 int *tx_head=NULL, *tx_tail=NULL;	 
-
-	 aidobj = container_of(pstat, struct aid_obj, station);
-	 priv = aidobj->priv;
 
-	if (!(priv->drv_state & DRV_STATE_OPEN)) {
-		return;
-	}
+/*return: 1: not finished,  0: the queue is empty now*/
+__MIPS16
+__IRAM_IN_865X
+__inline__ static int rtl8192cd_swq_dequeue(struct rtl8192cd_priv *priv, struct stat_info *pstat,  unsigned char qnum)
+{
+    int count = 0;
+    
+    while(1)
+    {
+        struct sk_buff *tmpskb;
+        tmpskb = skb_dequeue(&pstat->swq.swq_queue[qnum]);
+        if (tmpskb == NULL)
+            break;
+#ifdef SW_TXQ_RSVD_DESC
+        int pri = get_skb_priority(priv, tmpskb, pstat);
+        if (pstat->ADDBA_ready[pri] && (priv->pshare->swq_skb_queue_cnt[qnum - 1] > 0))
+            priv->pshare->swq_skb_queue_cnt[qnum - 1]--;
+#endif	
 
-	SMP_LOCK_XMIT(x);
-	SAVE_INT_AND_CLI(x);	 
-		 
-#ifdef CONFIG_WLAN_HAL	 
-	 if(IS_HAL_CHIP(priv))	 {
-		 if(compareAvailableTXBD(priv, 4, qnum, 2))
-			 bdfull = 1;
-	}else if(CONFIG_WLAN_NOT_HAL_EXIST) 
+#ifdef TX_EARLY_MODE
+        if (GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+            get_tx_early_info(priv, pstat, &pstat->swq.swq_queue[qnum]);
 #endif
-	{
-		 tx_head = get_txhead_addr(GET_HW(priv), qnum);
-		 tx_tail = get_txtail_addr(GET_HW(priv), qnum);
-		 if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
-			 bdfull = 1;
-	 }
-
-
-    while(1) {
-		if(bdfull) {	   
-			struct sk_buff_head *pqueue = &pstat->swq.vi_queue;
-			struct timer_list *ptimer;
-			int aggnum=pstat->swq.q_aggnum[qnum];
-			ptimer = &pstat->swq.viq_timer; 				
-		   
-		   if(skb_queue_len(pqueue) <= aggnum*2) 
-		   {
-			   pstat->swq.q_used[qnum]=1;
-			   if (!timer_pending(ptimer))
-			   {				   
-				   ptimer->data = (unsigned long) pstat;
-				   ptimer->function = rtl8192cd_viq_timer; //rtl8190_tmp_timer;
-				   mod_timer(ptimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(30));
-			   }
-			   break;
-		   }
-		}		
-		
-    	skb = skb_dequeue(&pstat->swq.vi_queue);
 
-        if (skb == NULL)
-        	break;
-		
-	
-		
-#ifdef TX_EARLY_MODE
-	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
-		get_tx_early_info(priv, pstat, &pstat->swq.vi_queue);		
-#endif		
-		
+		priv->ext_stats.swq_xmit_out_pkt++;
+
 #if defined(CONFIG_RTK_MESH)
-		__rtl8192cd_start_xmit_out(skb, pstat, NULL);
+        __rtl8192cd_start_xmit_out(tmpskb, pstat, NULL);
 #else
-        __rtl8192cd_start_xmit_out(skb, pstat);
+        __rtl8192cd_start_xmit_out(tmpskb, pstat);
 #endif
-		
-			pstat->swq.q_TOCount[VI_QUEUE]++;
+        count++;
     }
-	if(skb_queue_len(&pstat->swq.vi_queue) ==0)
-    	pstat->swq.viq_empty = 0;
 
-	RESTORE_INT(x);	
-    SMP_UNLOCK_XMIT(x);
-    
-	if(!bdfull) {
-	    SAVE_INT_AND_CLI(x);
-	    SMP_LOCK(x);
-		adjust_swq_setting(priv, pstat, VI_QUEUE, CHECK_DEC_AGGN);
-	    SMP_UNLOCK(x);
-		RESTORE_INT(x);
-	}
+    if(skb_queue_len(&pstat->swq.swq_queue[qnum]) == 0) {        
+        if(priv->pshare->swq_use_hw_timer && pstat->swq.swq_empty[qnum] == 1)
+            priv->pshare->swq_numActiveSTA--;
+        pstat->swq.swq_empty[qnum] = 0;        
+    }
+        
+    return count;
 }
 
-void rtl8192cd_voq_timer(unsigned long task_priv)
+__inline__ static int rtl8192cd_swq_enqueue(struct rtl8192cd_priv *priv, struct sk_buff *skb, struct stat_info	*pstat)
 {
-	 struct stat_info		 *pstat = (struct stat_info *)task_priv;
-	 struct sk_buff *skb = NULL;
-	 struct rtl8192cd_priv *priv = NULL;
-	 unsigned long x = 0, bdfull=0, qnum = VO_QUEUE;
-	 struct aid_obj *aidobj;	 
-	 int *tx_head=NULL, *tx_tail=NULL;	 
-	 
-	  aidobj = container_of(pstat, struct aid_obj, station);
-	  priv = aidobj->priv;
-	 
-	 if (!(priv->drv_state & DRV_STATE_OPEN)) {
-		 return;
-	 }
-	SMP_LOCK_XMIT(x);
-	SAVE_INT_AND_CLI(x);	 
-	
-#ifdef CONFIG_WLAN_HAL	 	 
-	 if(IS_HAL_CHIP(priv))	 {
-		 if(compareAvailableTXBD(priv, 4, qnum, 2))
-			 bdfull = 1;
-	}else if(CONFIG_WLAN_NOT_HAL_EXIST)
+    int q_len, pri, q_num;
+    unsigned char need_deque = 0;
+    UINT32 tri_time;
+    int assoc_num;
+    int i;
+    
+    pri = get_skb_priority(priv, skb, pstat);
+#if defined(RTL_MANUAL_EDCA)
+    q_num = PRI_TO_QNUM(priv, pri);
+#else
+    PRI_TO_QNUM(pri, q_num, priv->pmib->dot11OperationEntry.wifi_specific);
 #endif
+    
+    if(priv->pshare->swq_use_hw_timer) {
+        assoc_num = GET_ROOT(priv)->assoc_num;
+        #ifdef MBSSID
+        if (GET_ROOT(priv)->pmib->miscEntry.vap_enable){
+            struct rtl8192cd_priv *vap_priv;
+            for (i=0; i<RTL8192CD_NUM_VWLAN; ++i) {
+                vap_priv = GET_ROOT(priv)->pvap_priv[i];
+                if (vap_priv && 
+                    IS_DRV_OPEN(vap_priv) && 
+                    (GET_MIB(vap_priv)->dot11OperationEntry.opmode & WIFI_AP_STATE)
+                    ) 
+                {
+                    assoc_num += vap_priv->assoc_num;
+                }
+            }
+        }
+        #endif	
+        
+	/* IOT for some STAs Rx test */
+	if ((assoc_num == 1) && (7500000 < pstat->rx_avarage) &&  ((pstat->tx_avarage * 10) <  pstat->rx_avarage) && (priv->pshare->rssi_min > 40))  /* Rx Check : Rx > 60M && Rx > 10 * Tx && rssi > 40% */
 	{
-		 tx_head = get_txhead_addr(GET_HW(priv), qnum);
-		 tx_tail = get_txtail_addr(GET_HW(priv), qnum);
-		 if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
-			 bdfull = 1;
-	 }
-
-    while(1) {
-
-		if(bdfull) {	   
-			struct sk_buff_head *pqueue = &pstat->swq.vo_queue;
-			struct timer_list *ptimer;
-			int aggnum=pstat->swq.q_aggnum[qnum];
-			ptimer = &pstat->swq.voq_timer; 			
-					   
-		   if(skb_queue_len(pqueue) <= aggnum*2) 
-		   {
-			   pstat->swq.q_used[qnum]=1;
-			   if (!timer_pending(ptimer))
-			   {				   
-				   ptimer->data = (unsigned long) pstat;
-				   ptimer->function = rtl8192cd_voq_timer; //rtl8190_tmp_timer;
-				   mod_timer(ptimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(30));
-			   }
-			   break;
-		   }
-		}
-
-    	skb = skb_dequeue(&pstat->swq.vo_queue);
-
-        if (skb == NULL)
-        	break;
-		
+	        if (pstat->swq.swq_en[q_num]) {
+	            if (34375000 < pstat->rx_avarage) { /* 275M < TP */
+	                pstat->swq.swq_en[q_num] = 0; /*disable swq*/
+	                if (pstat->swq.swq_timer_id[q_num])
+	                    rtl8192cd_swq_deltimer(priv, pstat, q_num);
+	                if(pstat->swq.swq_empty[q_num])
+	                    rtl8192cd_swq_dequeue(priv, pstat, q_num);
+	            }
+	        }
+	        else {
+	            if (pstat->rx_avarage < 33750000) { /* TP < 270M */
+	                pstat->swq.swq_en[q_num] = 1; /*enable swq*/
+	                pstat->swq.swq_prev_timeout[q_num] = 0;
+	                pstat->swq.swq_timeout_change[q_num] = 0;
+	                pstat->swq.swq_keeptime[q_num] = 0;
+	           }
+	        }
+	}
+	else
+	{
+	        /*check if we need to enable/disable the swq for the specific q_num and pstat*/
+	        if(pstat->swq.swq_en[q_num] && assoc_num <= 8) {
+	            if(pstat->tx_avarage < 625000 || 20000000 < pstat->tx_avarage) { /* 5M < TP  or 160M < TP*/
+	                pstat->swq.swq_en[q_num] = 0; /*disable swq*/  
+	                if (pstat->swq.swq_timer_id[q_num])
+	                    rtl8192cd_swq_deltimer(priv, pstat, q_num);
+	                if(pstat->swq.swq_empty[q_num])
+	                    rtl8192cd_swq_dequeue(priv, pstat, q_num);                          
+	            }
+	        }
+	        else {
+	            if(assoc_num > 8 || (687500 < pstat->tx_avarage && pstat->tx_avarage < 19375000)) { /* 5.5M < TP < 155M*/
+	                pstat->swq.swq_en[q_num] = 1; /*enable swq*/ 
+	                pstat->swq.swq_prev_timeout[q_num] = 1;
+	                pstat->swq.swq_timeout_change[q_num] = 0;
+	                pstat->swq.swq_keeptime[q_num] = 0;         
+	           }
+	        }
+	}
 
-#ifdef TX_EARLY_MODE
-	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
-		get_tx_early_info(priv, pstat, &pstat->swq.vo_queue);		
-#endif		
-		
-#if defined(CONFIG_RTK_MESH)
-		__rtl8192cd_start_xmit_out(skb, pstat, NULL);
-#else
-        __rtl8192cd_start_xmit_out(skb, pstat);
+        if(pstat->swq.swq_en[q_num] == 0) {
+			
+			priv->ext_stats.swq_xmit_out_pkt++;
+
+
+			
+            #if defined(CONFIG_RTK_MESH)
+            __rtl8192cd_start_xmit_out(skb, pstat, NULL);
+            #else
+            __rtl8192cd_start_xmit_out(skb, pstat);
+            #endif
+            return 0;
+        }
+    }
+    
+    pstat->swq.q_used[q_num] = 1;    
+    if (!pstat->ADDBA_ready[pri])
+    {
+        need_deque = 1;
+    }
+    
+    if(need_deque == 0) {    
+        q_len = skb_queue_len(&pstat->swq.swq_queue[q_num]);
+        #ifdef TX_EARLY_MODE
+        if (q_len + 1 >= (GET_EM_SWQ_ENABLE ? MAX_EM_QUE_NUM : pstat->swq.q_aggnum[q_num])) {
+        #else
+        if (q_len + 1 >= pstat->swq.q_aggnum[q_num]) {
+        #endif		
+            need_deque = 1;
+        } 
+    }
+
+    if(need_deque) {
+        if (pstat->swq.swq_timer_id[q_num])
+            rtl8192cd_swq_deltimer(priv, pstat, q_num);
+        if(rtl8192cd_swq_bdfull(priv, pstat, q_num)) {           
+            skb_queue_tail(&pstat->swq.swq_queue[q_num], skb);
+            if(priv->pshare->swq_use_hw_timer && pstat->swq.swq_empty[q_num] == 0) {
+                priv->pshare->swq_numActiveSTA++;
+                if(priv->pshare->swq_numActiveSTA == 9) {
+                    turbo_swq_setting(priv);
+                    priv->pshare->swq_turbo_time = priv->up_time;
+                }
+            }
+            pstat->swq.swq_empty[q_num] = 1;                                       
+#ifdef SW_TXQ_RSVD_DESC
+            if (pstat->ADDBA_ready[pri])
+                priv->pshare->swq_skb_queue_cnt[q_num - 1]++;
 #endif
-		
-			pstat->swq.q_TOCount[VO_QUEUE]++;
+        }
+        else {
+            if(pstat->swq.swq_empty[q_num])
+                rtl8192cd_swq_dequeue(priv, pstat, q_num);
+
+			priv->ext_stats.swq_xmit_out_pkt++;
+
+            #if defined(CONFIG_RTK_MESH)
+            __rtl8192cd_start_xmit_out(skb, pstat, NULL);
+            #else
+            __rtl8192cd_start_xmit_out(skb, pstat);        
+            #endif
+        }
+    }
+    else {
+        skb_queue_tail(&pstat->swq.swq_queue[q_num], skb);
+        if(priv->pshare->swq_use_hw_timer && pstat->swq.swq_empty[q_num] == 0) {
+            priv->pshare->swq_numActiveSTA++;
+            if(priv->pshare->swq_numActiveSTA == 9) {
+                turbo_swq_setting(priv);
+                priv->pshare->swq_turbo_time = priv->up_time;
+            }
+        }
+        pstat->swq.swq_empty[q_num] = 1;  
+#ifdef SW_TXQ_RSVD_DESC
+        if (pstat->ADDBA_ready[pri])
+            priv->pshare->swq_skb_queue_cnt[q_num - 1]++;
+#endif    
     }
-	if(skb_queue_len(&pstat->swq.vo_queue) ==0)
-  	  pstat->swq.voq_empty = 0;
 
-	RESTORE_INT(x);
-	SMP_UNLOCK_XMIT(x);
-    
-	if(!bdfull) {
-	    SAVE_INT_AND_CLI(x);
-	    SMP_LOCK(x);
-		adjust_swq_setting(priv, pstat, VO_QUEUE, CHECK_DEC_AGGN);
-		SMP_UNLOCK(x);
-		RESTORE_INT(x);
-	}
-}
+    if(pstat->swq.swq_empty[q_num]) { /*queue not empty, add timer for it*/        
+        if (pstat->swq.swq_timer_id[q_num] == 0)
+        {           
+            if(priv->pshare->swq_use_hw_timer) {
+		if(priv->pshare->swq_numActiveSTA > 8 && (priv->up_time - priv->pshare->swq_turbo_time) < priv->pshare->rf_ft_var.swqmaxturbotime)
+                    tri_time = 20;
+                else if (pstat->tx_avarage > 13750000)           // 110M~
+                	tri_time = priv->pshare->rf_ft_var.tri_time1;
+                else if (pstat->tx_avarage > 1875000)       //15M~110M
+                    tri_time = priv->pshare->rf_ft_var.tri_time2;
+                else if (pstat->tx_avarage > 625000)        //5M~15M
+                    tri_time = priv->pshare->rf_ft_var.tri_time3;
+                else if (pstat->tx_avarage > 250000)        //2M~5M
+                    tri_time = priv->pshare->rf_ft_var.tri_time4;
+                else if (pstat->tx_avarage > 100000)        //800K~2M
+                    tri_time = priv->pshare->rf_ft_var.tri_time5;
+                else if (pstat->tx_avarage > 25000)	        //200K~800K
+                	tri_time = priv->pshare->rf_ft_var.tri_time6;
+                else
+                    tri_time = priv->pshare->rf_ft_var.tri_time7;
+                       
+                if(pstat->swq.swq_prev_timeout[q_num] != tri_time) {
+                    pstat->swq.swq_prev_timeout[q_num] = tri_time;
+                    pstat->swq.swq_timeout_change[q_num] = 1;                                 
+                }  
+                tri_time = RTL_R32(TSFTR1) + tri_time*1000;
+            }
+            else {
+                if (pstat->tx_avarage > 1875000) 					//15M~
+                    tri_time = 1;
+                else if (pstat->tx_avarage > 500000) 					//4M~15M
+                    tri_time = 30;
+                else if (pstat->tx_avarage > 250000) //2M~4M
+                    tri_time = 90;
+                else if (pstat->tx_avarage > 100000)					 //800K~2M
+                    tri_time = 120;              
+                else
+                    tri_time = 10;    
+                
+                tri_time = jiffies + RTL_MILISECONDS_TO_JIFFIES(tri_time);
+            }
 
-__MIPS16
-__IRAM_IN_865X
-int sw_dequeue(struct rtl8192cd_priv *priv, struct sk_buff_head *pqueue,  struct timer_list *ptimer)//, int *pempty)
-{
-	struct stat_info       *pstat = (struct stat_info *)ptimer->data;
-	int *tx_head=NULL, *tx_tail=NULL, bdfull=0, qnum = BE_QUEUE;
+            rtl8192cd_swq_addtimer(priv, pstat, q_num, tri_time);           
+            rtl8192cd_swq_settimer(priv, tri_time);   /*need to re-setup timer*/                        
+        }
+    }
 
-    if (timer_pending(ptimer))
-        del_timer(ptimer);
-	
-	if(pqueue == &pstat->swq.bk_queue)
-		qnum = BK_QUEUE;
-	else if(pqueue == &pstat->swq.vi_queue)
-		qnum = VI_QUEUE;
-	else if(pqueue == &pstat->swq.vo_queue)
-		qnum = VO_QUEUE;
+    return 0;
+ }
 
-#ifdef CONFIG_WLAN_HAL	 	 
-	 if(IS_HAL_CHIP(priv))	 {
-		 if(compareAvailableTXBD(priv, 4, qnum, 2))
-			 bdfull = 1;
-	} else if(CONFIG_WLAN_NOT_HAL_EXIST)
-#endif
-	{
-		 tx_head = get_txhead_addr(GET_HW(priv), qnum);
-		 tx_tail = get_txtail_addr(GET_HW(priv), qnum);
-		 if((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
-			 bdfull = 1;
-	 }
+void rtl8192cd_swq_timeout(unsigned long task_priv)
+{
+    struct rtl8192cd_priv        *priv = (struct rtl8192cd_priv *)task_priv;
+    struct sw_tx_queue_timer* swq_timer;
+    int head;
+    unsigned char add_timer;
+    unsigned char need_dequeue;  
+    unsigned char set_timer = 0;
+    
+    UINT32 add_timer_timeout;
+    UINT32 set_timer_timeout = 0;
+    struct stat_info * pstat;
+    struct rtl8192cd_priv *priv_this=NULL;
+    unsigned char qnum;    
+    UINT32 current_time;
+    int bdfull;
+    unsigned long x = 0;
+    SMP_LOCK_XMIT(x);
+    SAVE_INT_AND_CLI(x);
+    
+    priv->pshare->swq_current_timeout = 0;
+    if(priv->pshare->swq_use_hw_timer) {     
+        current_time = RTL_R32(TSFTR1);
+    }
+    else {
+        current_time = jiffies;
+    }
+  
 
-    while(1)
+    head = priv->pshare->swq_timer_head;
+    while (head != priv->pshare->swq_timer_tail) //check if queue is empty
     {
-        struct sk_buff *tmpskb;
+        priv->pshare->swq_timer_tail = (priv->pshare->swq_timer_tail + 1) % SWQ_TIMER_NUM;    
+        swq_timer = &priv->pshare->swq_timer[priv->pshare->swq_timer_tail];
+        if (swq_timer->pstat) {           
+            pstat = swq_timer->pstat;            
+            priv_this = swq_timer->priv;
+            qnum = swq_timer->qnum;
+            add_timer_timeout = swq_timer->timeout;
 
-		if(bdfull) {				
-			break;
-		}
+            swq_timer->pstat = NULL;
+            pstat->swq.swq_timer_id[qnum] = 0;
 
-    	tmpskb = skb_dequeue(pqueue);
-        if (tmpskb == NULL)
-           	break;
 
-#ifdef TX_EARLY_MODE
-	if (GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
-		get_tx_early_info(priv, pstat, pqueue);
-#endif
-#if defined(CONFIG_RTK_MESH)
-		__rtl8192cd_start_xmit_out(tmpskb, pstat, NULL);
-#else
-        __rtl8192cd_start_xmit_out(tmpskb, pstat);
-#endif
-	}
-	return 0;
-}
+            if (!(priv_this->drv_state & DRV_STATE_OPEN)) {
+                continue;
+            }   
 
-__MIPS16
-__IRAM_IN_865X
-int sw_enqueue(struct rtl8192cd_priv *priv, struct sk_buff *skb, struct stat_info	*pstat)
-{
-	int q_len, pri, q_num, tri_time, *pempty, aggnum;
-	struct sk_buff_head *pqueue;
-	struct timer_list *ptimer;
-	void (*timer_hook)(unsigned long task_priv);
+            need_dequeue = 0;
+            if(priv->pshare->swq_use_hw_timer) {     
+                if(add_timer_timeout -  (current_time + SWQ_HWTIMER_TOLERANCE) > SWQ_HWTIMER_MAXIMUN) {
+                    need_dequeue = 1;
+                }
+            }
+            else {
+                if(add_timer_timeout <= current_time) {
+                    need_dequeue = 1;
+                }
+            }
+            
+            add_timer = 0;
+            if(need_dequeue) {  
+                bdfull = rtl8192cd_swq_bdfull(priv, pstat, qnum);
+                if(bdfull && skb_queue_len(&pstat->swq.swq_queue[qnum]) < pstat->swq.q_aggnum[qnum]*2 ) {
+                    add_timer = 1;
+                    if(priv->pshare->swq_use_hw_timer) {                        
+                        add_timer_timeout = 1;   
+                        add_timer_timeout = add_timer_timeout*1000; // to us
+                    }
+                    else {
+                        add_timer_timeout = 30;   
+                        add_timer_timeout = RTL_MILISECONDS_TO_JIFFIES(add_timer_timeout); 
+                    }
+                    add_timer_timeout += current_time; 
 
-	pri = get_skb_priority(priv, skb, pstat);
-#if defined(RTL_MANUAL_EDCA)
-	q_num = PRI_TO_QNUM(priv, pri);
-#else
-	PRI_TO_QNUM(pri, q_num, priv->pmib->dot11OperationEntry.wifi_specific);
-#endif
-	switch(q_num)
-	{
-		case BK_QUEUE:
-			pqueue = &pstat->swq.bk_queue;
-			ptimer = &pstat->swq.bkq_timer;
-			timer_hook = rtl8192cd_bkq_timer;
-			pempty = &pstat->swq.bkq_empty;
-			pstat->swq.q_used[BK_QUEUE]=1;
-			aggnum=pstat->swq.q_aggnum[BK_QUEUE];
-			break;
-		case VO_QUEUE:
-			pqueue = &pstat->swq.vo_queue;
-			ptimer = &pstat->swq.voq_timer;
-			timer_hook = rtl8192cd_voq_timer;
-			pempty = &pstat->swq.voq_empty;
-			pstat->swq.q_used[VO_QUEUE]=1;
-			aggnum=pstat->swq.q_aggnum[VO_QUEUE];
-			break;
-		case VI_QUEUE:
-			pqueue = &pstat->swq.vi_queue;
-			ptimer = &pstat->swq.viq_timer;
-			timer_hook = rtl8192cd_viq_timer;
-			pempty = &pstat->swq.viq_empty;
-			pstat->swq.q_used[VI_QUEUE]=1;
-			aggnum=pstat->swq.q_aggnum[VI_QUEUE];
-			break;
-		//case BE_QUEUE:
-		default:
-			pqueue = &pstat->swq.be_queue;
-			ptimer = &pstat->swq.beq_timer;
-			timer_hook = rtl8192cd_beq_timer;
-			pempty = &pstat->swq.beq_empty;
-			pstat->swq.q_used[BE_QUEUE]=1;
-			aggnum=pstat->swq.q_aggnum[BE_QUEUE];
-			break;
-	}
+                }
+                else {
+                        if(priv->pshare->swq_use_hw_timer) {
+                        rtl8192cd_swq_dequeue(priv_this, pstat, qnum);
+                            pstat->swq.q_TOCount[qnum]++;                        
+                        }
+                        else {
+                        pstat->swq.q_TOCount[qnum] += rtl8192cd_swq_dequeue(priv_this, pstat, qnum); 
+                        }
+                }
+                
+                if(!bdfull) {
+                    adjust_swq_setting(priv, pstat, qnum, CHECK_DEC_AGGN);
+                }  
+            }
+            else {                        
+                add_timer = 1;
+            }
 
-	skb_queue_tail(pqueue, skb);
-	ptimer->data = (unsigned long)pstat;
 
-	if (!pstat->ADDBA_ready[pri])
-	{
-		sw_dequeue(priv, pqueue, ptimer);
-		if(skb_queue_len(pqueue) ==0)
-			*pempty = 0;
-		return 0;
-	}
+            if(add_timer) { 
+                rtl8192cd_swq_addtimer(priv_this, pstat, qnum, add_timer_timeout);  
+                if(set_timer == 0) {
+                    set_timer_timeout = add_timer_timeout;
+                }
+                else {
+                    if(priv->pshare->swq_use_hw_timer) { 
+                        if(add_timer_timeout - set_timer_timeout > SWQ_HWTIMER_MAXIMUN) {
+                            set_timer_timeout = add_timer_timeout;
+                        }
+                    }
+                    else {
+                        if(add_timer_timeout < set_timer_timeout) {
+                            set_timer_timeout = add_timer_timeout;
+                        }                    
+                    }
+                }                
+                
+                set_timer = 1;
+            }
+        }
 
-	q_len = skb_queue_len(pqueue);
-//	if(priv->assoc_num == 1)
-//		aggnum = priv->pshare->rf_ft_var.swq_aggnum;
 
-#ifdef TX_EARLY_MODE
-	if (q_len >= (GET_EM_SWQ_ENABLE ? MAX_EM_QUE_NUM : aggnum)) {
-#else
-	if (q_len >= aggnum) {
-#endif		
-		sw_dequeue(priv, pqueue, ptimer);//, pempty);
-		if(skb_queue_len(pqueue) ==0)
-			*pempty = 0;
-		return 0;
-	} else if (q_len == 1) {
-		if (!timer_pending(ptimer))
-		{
-			if ((pstat->tx_avarage > 1875000)) 					//15M~
-				tri_time = RTL_MILISECONDS_TO_JIFFIES(10);
-			else if ((pstat->tx_avarage > 500000)) 					//4M~15M
-				tri_time = RTL_MILISECONDS_TO_JIFFIES(30);
-			else if ((pstat->tx_avarage > 250000) && (pstat->tx_avarage <= 500000)) //2M~4M
-				tri_time = RTL_MILISECONDS_TO_JIFFIES(90);
-			else if ((pstat->tx_avarage > 100000))					 //800K~2M
-				tri_time = RTL_MILISECONDS_TO_JIFFIES(120);
-			else
-				tri_time = RTL_MILISECONDS_TO_JIFFIES(10);
-			
-			ptimer->data = (unsigned long) pstat;
-			ptimer->function = timer_hook; //rtl8190_tmp_timer;
-			mod_timer(ptimer, jiffies + tri_time);
-		}
-	}
+    }
 
-	*pempty = 1;
-	return 0;
-}
-#endif
+    if(set_timer) {
+        rtl8192cd_swq_settimer(priv, set_timer_timeout);   /*need to re-setup timer*/
+    }    
+
+    priv->pshare->has_triggered_sw_tx_Q_tasklet = 0;
+
+    RESTORE_INT(x);		
+    SMP_UNLOCK_XMIT(x);    
+}    
+#endif //SW_TX_QUEUE
 
 #ifndef SW_TX_QUEUE
 __MIPS16
@@ -7795,10 +7894,7 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 #endif
 	struct net_device *wdsDev = NULL;
 #ifdef SW_TX_QUEUE
-	int q_num, *pempty;
 	int swq_out = 0;
-    struct sk_buff_head *pqueue;
-    struct timer_list *ptimer;
 #endif
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	struct vlan_info *vlan=NULL;
@@ -7819,6 +7915,7 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	unsigned long flags;
 #endif
 	int locked=0;	
+	unsigned short  protocol;
 
 
 	DECLARE_TXCFG(txcfg, tx_insn);
@@ -8289,6 +8386,13 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	}
 #endif // WDS
 
+       protocol = ntohs(*((UINT16 *)((UINT8 *)skb->data + ETH_ALEN*2)));
+
+       if ( (isDHCPpkt(skb) == TRUE) || (protocol == 0x888E) )
+            txcfg->is_urg_pkt = 1;
+       else
+            txcfg->is_urg_pkt = 0; 
+
 	if (priv->pmib->miscEntry.func_off || priv->pmib->miscEntry.raku_only) {
 		goto free_and_stop;
 	}
@@ -8481,7 +8585,10 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 
 #ifdef SW_TX_QUEUE
 		if (pstat)
-			swq_out = priv->pshare->swq_en | pstat->swq.beq_empty | pstat->swq.viq_empty | pstat->swq.voq_empty | pstat->swq.bkq_empty;
+			swq_out = priv->pshare->swq_en | pstat->swq.swq_empty[BK_QUEUE] | 
+			                         pstat->swq.swq_empty[BE_QUEUE] | 
+			                         pstat->swq.swq_empty[VO_QUEUE] | 
+			                         pstat->swq.swq_empty[VI_QUEUE];
 #endif
 	}
 #ifdef DETECT_STA_EXISTANCE
@@ -8524,44 +8631,17 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 #else
 			return __rtl8192cd_start_xmit_out(skb, pstat);
 #endif
-	} else if (priv->pshare->swq_en) {
-		return sw_enqueue(priv,skb,pstat);
-	} else {
-		//if ((pstat != NULL) && (priv->pshare->rf_ft_var.swq_enable == 1) && (AMPDU_ENABLE != 0))
-			//ptimer->data = (unsigned long)pstat;
-		for(q_num = BK_QUEUE; q_num <= VO_QUEUE; q_num++)
+	} else if (priv->pshare->swq_en && !txcfg->is_urg_pkt) {//swq_en=1
+        	priv->ext_stats.swq_enque_pkt++;
+		return rtl8192cd_swq_enqueue(priv, skb, pstat);
+	} else { //swq_en=0 and swq still have packet queuing
+		for(temp = BK_QUEUE; temp <= VO_QUEUE; temp++)
 		{
-			switch(q_num)
-			{
-				case BK_QUEUE:
-					pqueue = &pstat->swq.bk_queue;		
-					ptimer = &pstat->swq.bkq_timer;
-					pempty = &pstat->swq.bkq_empty;
-					break;
-				case VO_QUEUE:
-	                pqueue = &pstat->swq.vo_queue;
-					ptimer = &pstat->swq.voq_timer;
-					pempty = &pstat->swq.voq_empty;
-	                break;
-				case VI_QUEUE:
-	                pqueue = &pstat->swq.vi_queue;
-					ptimer = &pstat->swq.viq_timer;
-					pempty = &pstat->swq.viq_empty;
-	                break;
-				//case BE_QUEUE:
-				default:
-	                pqueue = &pstat->swq.be_queue;
-					ptimer = &pstat->swq.beq_timer;
-					pempty = &pstat->swq.beq_empty;
-	                break;
+			if(pstat->swq.swq_empty[temp]) {                
+				if (pstat->swq.swq_timer_id[temp])
+					rtl8192cd_swq_deltimer(priv, pstat, temp);                                
+				rtl8192cd_swq_dequeue(priv, pstat, temp);
 			}				
-
-			if (*pempty == 0)
-				continue;
-
-			ptimer->data = (unsigned long)pstat;
-			sw_dequeue(priv, pqueue, ptimer);//, pempty, pstat);
-			*pempty = 0;
 		}
 
 #if defined(CONFIG_RTK_MESH)
@@ -9023,7 +9103,7 @@ int __rtl8192cd_usb_start_xmit(struct rtl8192cd_priv *priv, struct tx_insn* txcf
 
             if(
 #ifdef CONFIG_WLAN_HAL
-            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/2), q_num, 2)) :
+            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/2), q_num, 2, txcfg->is_urg_pkt)) :
 #endif // CONFIG_WLAN_HAL
             (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < CURRENT_NUM_TX_DESC/2)
 
@@ -9041,7 +9121,7 @@ int __rtl8192cd_usb_start_xmit(struct rtl8192cd_priv *priv, struct tx_insn* txcf
 
             if(
 #ifdef CONFIG_WLAN_HAL
-            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, 32, q_num, 2)) : 
+            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, 32, q_num, 2, txcfg->is_urg_pkt)) : 
 #endif // CONFIG_WLAN_HAL
             (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < 10)
 
@@ -9050,6 +9130,25 @@ int __rtl8192cd_usb_start_xmit(struct rtl8192cd_priv *priv, struct tx_insn* txcf
 				rtl8192cd_tx_queueDsr(priv, q_num);
 			}
 
+				int num_swq_rsvd = 0;
+#ifdef SW_TXQ_RSVD_DESC
+				int pri_t = pstat->tx_sc_ent[k].pktpri;
+				int q_num_t = pstat->tx_sc_ent[k].txcfg.q_num;
+				if (q_num_t>=BK_QUEUE && q_num_t<=VO_QUEUE)
+				{
+					if (!pstat->ADDBA_ready[pri_t])
+					{
+						int max_queue_cnt = CURRENT_NUM_TX_DESC >> 3;
+						if (priv->pshare->swq_skb_queue_cnt[q_num_t - 1] >= max_queue_cnt)
+							num_swq_rsvd = max_queue_cnt;
+						else
+							num_swq_rsvd = priv->pshare->swq_skb_queue_cnt[q_num_t - 1];
+
+						num_swq_rsvd = num_swq_rsvd >> 1;
+					}
+				}
+#endif
+
 #ifdef RESERVE_TXDESC_FOR_EACH_IF
 			if ( GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc ) {
 				if( check_txdesc_dynamic_mechanism(priv, q_num, 2) ) {
@@ -9079,7 +9178,7 @@ int __rtl8192cd_usb_start_xmit(struct rtl8192cd_priv *priv, struct tx_insn* txcf
             if(
 #ifdef CONFIG_WLAN_HAL
             IS_HAL_CHIP(priv) ? 
-                ( compareAvailableTXBD(priv, ((GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) ? 14 : 4), q_num, 2)) :
+                ( compareAvailableTXBD(priv, ((GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) ? 14 : 4), q_num, 2, txcfg->is_urg_pkt)) :
 #endif // CONFIG_WLAN_HAL
                 (((GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) ? 14 : 4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
 
@@ -9087,7 +9186,7 @@ int __rtl8192cd_usb_start_xmit(struct rtl8192cd_priv *priv, struct tx_insn* txcf
 #else
 			if(
 #ifdef CONFIG_WLAN_HAL
-            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, 4, q_num, 2)) : 
+            IS_HAL_CHIP(priv) ? (compareAvailableTXBD(priv, 4, q_num, 2, txcfg->is_urg_pkt)) : 
 #endif // CONFIG_WLAN_HAL			
 #ifdef TX_SCATTER
 			((ptxsc_entry->has_desc3 && 6 > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC)) ||
@@ -11301,6 +11400,31 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 #endif
 		}
 
+		int num_swq_rsvd = 0;
+#ifdef SW_TXQ_RSVD_DESC
+		int q_num_t = txcfg->q_num;
+		if (txcfg->fr_type==_SKB_FRAME_TYPE_ && q_num_t>=BK_QUEUE && q_num_t<=VO_QUEUE)
+		{
+			struct sk_buff *skb_t = (struct sk_buff *)txcfg->pframe;
+			struct stat_info *pstat_t = txcfg->pstat;
+			if (skb_t && pstat_t)
+			{
+				int pri_t = get_skb_priority(priv, skb_t, pstat_t);
+				int max_queue_cnt = CURRENT_NUM_TX_DESC >> 3;
+				if (!pstat_t->ADDBA_ready[pri_t])
+				{
+					int max_queue_cnt = CURRENT_NUM_TX_DESC >> 3;
+					if (priv->pshare->swq_skb_queue_cnt[q_num_t - 1] >= max_queue_cnt)
+						num_swq_rsvd = max_queue_cnt;
+					else
+						num_swq_rsvd = priv->pshare->swq_skb_queue_cnt[q_num_t - 1];
+
+					num_swq_rsvd = num_swq_rsvd >> 1;
+				}
+			}
+		}
+#endif
+
 #ifdef RESERVE_TXDESC_FOR_EACH_IF
 		if(GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc  && txcfg->fr_type == _SKB_FRAME_TYPE_) {
 			if (check_txdesc_dynamic_mechanism(priv, q_num, val32)) {
@@ -11339,9 +11463,16 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 #endif		
 #endif		
 		//SMP_LOCK_XMIT(x);
+
+		if (GetFrameType(txcfg->phdr) == WIFI_MGT_TYPE) {
+			txcfg->is_urg_pkt = TRUE;
+		} else {
+			txcfg->is_urg_pkt = FALSE;
+		}
+
 		if (
 #ifdef CONFIG_WLAN_HAL
-		IS_HAL_CHIP(priv)? (compareAvailableTXBD(priv, val32+1, q_num, 2))  :
+		IS_HAL_CHIP(priv)? (compareAvailableTXBD(priv, val32+1, q_num, 2, txcfg->is_urg_pkt))  :
 #endif
 		((val32 + 2) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC)) //per mpdu, we need 2 desc...
 		){
@@ -12381,7 +12512,7 @@ static void rtl88XX_tx_dsr(unsigned long task_priv)
 #ifdef CONFIG_WLAN_HAL
         ptx_dma = (PHCI_TX_DMA_MANAGER_88XX)(_GET_HAL_DATA(priv)->PTxDMA88XX);
 
-        if (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/2), BE_QUEUE, 1)) {
+        if (compareAvailableTXBD(priv, (CURRENT_NUM_TX_DESC/2), BE_QUEUE, 1, FALSE)) {
 			SMP_UNLOCK_XMIT(flags);
             mp_ctx(priv, (unsigned char *)"tx-isr");
 			SMP_LOCK_XMIT(flags);
diff --git a/driver/rtl8192cd/8192cd_util.c b/driver/rtl8192cd/8192cd_util.c
index 500e4a0..9958996 100755
--- a/driver/rtl8192cd/8192cd_util.c
+++ b/driver/rtl8192cd/8192cd_util.c
@@ -55,12 +55,7 @@
 #include "./8192cd_profile.h"
 extern unsigned char g_sc_ifname[32];
 #endif
-#ifdef __ECOS
-extern void rtl8192cd_beq_timer(void *task_priv);
-extern void rtl8192cd_bkq_timer(void *task_priv);
-extern void rtl8192cd_viq_timer(void *task_priv);
-extern void rtl8192cd_voq_timer(void *task_priv);
-#endif
+
 
 #if defined(USE_PID_NOTIFY) && defined(LINUX_2_6_27_)
 struct pid *_wlanapp_pid;
@@ -1284,22 +1279,14 @@ void init_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 
 #ifdef SW_TX_QUEUE
     SMP_LOCK_XMIT(flags);  
-    init_timer(&pstat->swq.beq_timer);
-    init_timer(&pstat->swq.bkq_timer);
-    init_timer(&pstat->swq.viq_timer);
-    init_timer(&pstat->swq.voq_timer);
-
-    skb_queue_head_init(&pstat->swq.be_queue);
-    skb_queue_head_init(&pstat->swq.bk_queue);
-    skb_queue_head_init(&pstat->swq.vi_queue);
-    skb_queue_head_init(&pstat->swq.vo_queue);
     for(i=BK_QUEUE;i<HIGH_QUEUE;i++) {	
         pstat->swq.q_aggnum[i] = 2;			
-
+	skb_queue_head_init(&pstat->swq.swq_queue[i]);
     }
     SMP_UNLOCK_XMIT(flags); 
 #endif
 
+
 	// we do NOT reset MAC here
 
 #if defined(WIFI_WMM)
@@ -1437,10 +1424,10 @@ void dump_sta_dz_queue_num(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 #endif
 
 #ifdef SW_TX_QUEUE
-	printk("swq.be_queue:%d\n",skb_queue_len(&pstat->swq.be_queue));
-	printk("swq.bk_queue:%d\n",skb_queue_len(&pstat->swq.bk_queue));
-	printk("swq.vi_queue:%d\n",skb_queue_len(&pstat->swq.vi_queue));
-	printk("swq.vo_queue:%d\n",skb_queue_len(&pstat->swq.vo_queue));
+	printk("swq.be_queue:%d\n",skb_queue_len(&pstat->swq.swq_queue[BE_QUEUE]));
+	printk("swq.bk_queue:%d\n",skb_queue_len(&pstat->swq.swq_queue[BK_QUEUE]));
+	printk("swq.vi_queue:%d\n",skb_queue_len(&pstat->swq.swq_queue[VI_QUEUE]));
+	printk("swq.vo_queue:%d\n",skb_queue_len(&pstat->swq.swq_queue[VO_QUEUE]));
 #endif
 
 #if defined(WIFI_WMM) && defined(WMM_APSD)
@@ -1476,6 +1463,7 @@ void free_sta_tx_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat)
     int				hd, tl;
 #endif
     struct sk_buff	*pskb;
+	int i;
     SMP_LOCK_XMIT(x);
     // free all skb in dz_queue
     while (skb_queue_len(&pstat->dz_queue)) {
@@ -1484,22 +1472,13 @@ void free_sta_tx_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat)
     }
 
 #ifdef SW_TX_QUEUE
-    while (skb_queue_len(&pstat->swq.be_queue)) {
-        pskb = skb_dequeue(&pstat->swq.be_queue);
-        rtl_kfree_skb(priv, pskb, _SKB_TX_);
-    }
-    while (skb_queue_len(&pstat->swq.bk_queue)) {
-        pskb = skb_dequeue(&pstat->swq.bk_queue);
-        rtl_kfree_skb(priv, pskb, _SKB_TX_);
-    }
-    while (skb_queue_len(&pstat->swq.vi_queue)) {
-        pskb = skb_dequeue(&pstat->swq.vi_queue);
-        rtl_kfree_skb(priv, pskb, _SKB_TX_);
-    }
-    while (skb_queue_len(&pstat->swq.vo_queue)) {
-        pskb = skb_dequeue(&pstat->swq.vo_queue);
-        rtl_kfree_skb(priv, pskb, _SKB_TX_);
-    }
+	for(i = BK_QUEUE; i < HIGH_QUEUE; i++) {
+		while (skb_queue_len(&pstat->swq.swq_queue[i])) {
+			pskb = skb_dequeue(&pstat->swq.swq_queue[i]);
+            		priv->ext_stats.swq_drop_pkt++;
+			rtl_kfree_skb(priv, pskb, _SKB_TX_);
+		}
+	}
 #endif
 
 #if defined(WIFI_WMM) && defined(WMM_APSD)
@@ -1707,23 +1686,6 @@ void release_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 	#endif
 #endif
 
-#ifdef SW_TX_QUEUE
-#ifdef SMP_SYNC		
-	SMP_TRY_LOCK_XMIT(flags,locked);
-#endif
-	if (timer_pending(&pstat->swq.beq_timer))
-                del_timer(&pstat->swq.beq_timer);
-	if (timer_pending(&pstat->swq.bkq_timer))
-                del_timer(&pstat->swq.bkq_timer);
-	if (timer_pending(&pstat->swq.viq_timer))
-                del_timer(&pstat->swq.viq_timer);
-	if (timer_pending(&pstat->swq.voq_timer))
-                del_timer(&pstat->swq.voq_timer);
-#ifdef SMP_SYNC				
-	if(locked)
-		SMP_UNLOCK_XMIT(flags);
-#endif
-#endif
 
 #ifdef CONFIG_IEEE80211W
 	if (timer_pending(&pstat->SA_timer))
@@ -1790,6 +1752,20 @@ void release_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 		if (priv->pshare->rc_timer[i].pstat == pstat)
 			priv->pshare->rc_timer[i].pstat = NULL;
 	SMP_UNLOCK_REORDER_CTRL(flags);
+#ifdef SW_TX_QUEUE
+#ifdef SMP_SYNC		
+	SMP_TRY_LOCK_XMIT(flags,locked);
+#endif
+	for (i = BK_QUEUE; i <= VO_QUEUE; i++) {
+		if(pstat->swq.swq_timer_id[i]) {
+		rtl8192cd_swq_deltimer(priv, pstat, i);
+		}
+	}
+#ifdef SMP_SYNC				
+	if(locked)
+		SMP_UNLOCK_XMIT(flags);
+#endif
+#endif
 
 #ifdef WDS
 	pstat->state &= WIFI_WDS;
@@ -6977,27 +6953,6 @@ int is_passive_channel(struct rtl8192cd_priv *priv , int domain, int chan)
 	return 0;
 }
 
-void init_STA_SWQAggNum(struct rtl8192cd_priv *priv)
-{
-#ifdef SW_TX_QUEUE
-	struct stat_info *sta;
-	int i, Idx = 0;
-	while(1) {
-		sta = findNextSTA(priv, &Idx);
-		if(sta) {
-			if(sta->tx_avarage> (1<<16)) {
-				for(i=BK_QUEUE;i<HIGH_QUEUE;i++) {	
-					  sta->swq.q_aggnum[i] = priv->pshare->rf_ft_var.swq_aggnum>>1;		
-				}
-			}
-		} else {			
-			return; 	
-		}
-	}
-#endif	
-}
-
-
 
 #if defined(TXREPORT)
 void requestTxReport(struct rtl8192cd_priv *priv)
@@ -7216,7 +7171,21 @@ void txrpt_handler_8812(struct rtl8192cd_priv *priv, struct tx_rpt *report, stru
 			
 		priv->pshare->current_tx_rate    = pstat->current_tx_rate;
 		priv->pshare->ht_current_tx_info = pstat->ht_current_tx_info;
+#if defined(MULTI_STA_REFINE) && defined(TX_SHORTCUT) && defined(SW_TX_QUEUE)
+		if( ((GET_CHIP_VER(priv) == VERSION_8192E) || (GET_CHIP_VER(priv)==VERSION_8812E)) ) {
+			if(	((pstat->current_tx_rate >= _MCS0_RATE_) && (pstat->current_tx_rate <= _MCS2_RATE_)) 
+				||((pstat->current_tx_rate >= _MCS8_RATE_) && (pstat->current_tx_rate <= _MCS10_RATE_)) 
+#ifdef RTK_AC_SUPPORT			
+				||((pstat->current_tx_rate >= _NSS1_MCS0_RATE_) && (pstat->current_tx_rate <= _NSS1_MCS2_RATE_)) 
+				||((pstat->current_tx_rate >= _NSS2_MCS0_RATE_) && (pstat->current_tx_rate <= _NSS2_MCS2_RATE_))
+#endif			
+			)
+				ratechg^=1;
+		}
 
+		if(ratechg && (priv->pshare->swq_numActiveSTA > LOWAGGRESTA))
+			clearTxShortCutBufSize(priv, pstat);
+#endif
 	}
 }
 #endif
@@ -8440,12 +8409,42 @@ void stats_conn_status_counts(struct rtl8192cd_priv *priv, unsigned int status)
 
 
 #ifdef SW_TX_QUEUE
+
+void turbo_swq_setting(struct rtl8192cd_priv *priv) 
+{
+    struct stat_info    *pstat;
+    int i,j;
+    for(i= 0; i<NUM_STAT; i++) {
+        if (priv->pshare->aidarray[i] && priv->pshare->aidarray[i]->used == TRUE) {
+            pstat = &(priv->pshare->aidarray[i]->station);
+            for(j=BK_QUEUE;j<HIGH_QUEUE;j++)
+                pstat->swq.q_aggnum[j] = priv->pshare->rf_ft_var.swqturboaggnum;
+        }
+    }
+}
 void adjust_swq_setting(struct rtl8192cd_priv *priv, struct stat_info *pstat, int i, int mode)
 {
-	int thd;
-	
+    int thd, step; 
+    int maxAggNum;
 	if(pstat->swq.q_used[i]) {
-		if (mode == CHECK_DEC_AGGN) {
+        if(priv->pshare->swq_use_hw_timer && priv->pshare->swq_numActiveSTA > 8 && 
+           (priv->up_time - priv->pshare->swq_turbo_time) < priv->pshare->rf_ft_var.swqmaxturbotime) {
+            pstat->swq.q_aggnum[i] = priv->pshare->rf_ft_var.swqturboaggnum;
+        }
+        else if (mode == CHECK_DEC_AGGN) {
+            if(priv->pshare->swq_use_hw_timer) {
+                thd = SWQ_TIMEOUT_THD / pstat->swq.swq_prev_timeout[i];    
+                if(thd > 100)
+                thd = 100;
+                if ((pstat->swq.q_TOCount[i] >= thd)&& ((pstat->swq.q_TOCount[i] % thd) == 0)) {                   
+                    if (pstat->swq.q_aggnum[i] > 1) {
+                        --(pstat->swq.q_aggnum[i]); 
+                        pstat->swq.swq_keeptime[i] = priv->up_time + 3;
+                    }
+                    pstat->swq.swq_timeout_change[i] = 0;                    
+                }                
+            }
+            else {
 			if (pstat->swq.q_aggnum[i] <= 2)
 				thd = priv->pshare->rf_ft_var.timeout_thd;
 			else if (pstat->swq.q_aggnum[i] <= 4)
@@ -8462,6 +8461,31 @@ void adjust_swq_setting(struct rtl8192cd_priv *priv, struct stat_info *pstat, in
 				DEBUG_INFO("dec,aid:%d,cnt:%d\n", pstat->aid, pstat->swq.q_TOCount[i]);
     		}
     	}
+        }
+        else {
+            if(priv->pshare->swq_use_hw_timer) {
+                if(priv->pshare->swq_numActiveSTA > 8)
+                    maxAggNum = priv->pshare->rf_ft_var.swqturboaggnum;
+                else
+                    maxAggNum = priv->pshare->rf_ft_var.swq_aggnum;
+
+                if(pstat->swq.q_aggnum[i] < maxAggNum && 
+                   pstat->swq.q_TOCount[i] < SWQ_TIMEOUT_THD_LOWER) {
+                    if(pstat->swq.swq_timeout_change[i]) {
+                        step = (maxAggNum - pstat->swq.q_aggnum[i] + 1)/2;
+                        if(step < 2)
+                            step = 2;
+                        pstat->swq.q_aggnum[i] += step;
+                        if (pstat->swq.q_aggnum[i] > maxAggNum) {                    
+                            pstat->swq.q_aggnum[i] = maxAggNum;
+                        }        
+                    }
+                    else {
+                        if(priv->up_time > pstat->swq.swq_keeptime[i])
+                            pstat->swq.q_aggnum[i]++;                        
+                    }
+                }			
+            }
     	else {
     		if (pstat->swq.q_aggnum[i] <= 2)
 				thd = priv->pshare->rf_ft_var.timeout_thd-10;
@@ -8471,7 +8495,7 @@ void adjust_swq_setting(struct rtl8192cd_priv *priv, struct stat_info *pstat, in
 				thd = priv->pshare->rf_ft_var.timeout_thd3-50;
 
 			if(pstat->swq.q_TOCount[i]< thd) {
-				int step = 1;
+                    step = 1;
 				if(pstat->swq.q_TOCount[i]< thd/5)
 					step = 5;
 				else if(pstat->swq.q_TOCount[i]< thd/3)
@@ -8486,7 +8510,36 @@ void adjust_swq_setting(struct rtl8192cd_priv *priv, struct stat_info *pstat, in
 		}
 	}
 }
-#endif
+}
+
+void init_STA_SWQAggNum(struct rtl8192cd_priv *priv)
+{
+    struct stat_info    *pstat;
+    int i,j;
+    unsigned long x = 0;
+	
+    for(i= 0; i<NUM_STAT; i++) {
+        if (priv->pshare->aidarray[i] && priv->pshare->aidarray[i]->used == TRUE) {
+            pstat = &(priv->pshare->aidarray[i]->station);
+           SMP_LOCK_XMIT(x);
+            for(j=BK_QUEUE;j<HIGH_QUEUE;j++) {
+                if(priv->pshare->swq_numActiveSTA > 8)
+                    pstat->swq.q_aggnum[j] = 16;
+                if(pstat->tx_avarage> (1<<16)) {
+                    pstat->swq.q_aggnum[j] = priv->pshare->rf_ft_var.swq_aggnum>>1;                               
+                }
+                if(priv->pshare->swq_use_hw_timer) {
+                    pstat->swq.swq_en[j] = 1;
+                    pstat->swq.swq_prev_timeout[j] = 1;
+                    pstat->swq.swq_timeout_change[j] = 0;
+                    pstat->swq.swq_keeptime[j] = 0;         
+                }
+            }
+           SMP_UNLOCK_XMIT(x);
+        }
+    }
+}
+#endif //SW_TX_QUEUE
 
 #if defined(CONFIG_RTL_ULINKER)
 int get_wlan_opmode(struct net_device *dev)
diff --git a/driver/rtl8192cd/8192cd_util.h b/driver/rtl8192cd/8192cd_util.h
index 20f46d4..71f9c6d 100755
--- a/driver/rtl8192cd/8192cd_util.h
+++ b/driver/rtl8192cd/8192cd_util.h
@@ -382,6 +382,7 @@
 #define RTL_JIFFIES_TO_MICROSECOND ((1000*1000)/HZ)
 #define RTL_JIFFIES_TO_MILISECONDS(x) (((x)*1000)/HZ)
 
+#define RTL_MICROSECONDS_TO_GTIMERCOUNTER(x) ((x)*100/3125 + 1)
 #define CHIP_VER_92X_SERIES(priv)		( (priv->pshare->version_id&0xf) < 3)
 
 #if defined(CONFIG_PCI_HCI)
diff --git a/driver/rtl8192cd/EdcaTurboCheck.c b/driver/rtl8192cd/EdcaTurboCheck.c
index b7836c8..af51f5b 100755
--- a/driver/rtl8192cd/EdcaTurboCheck.c
+++ b/driver/rtl8192cd/EdcaTurboCheck.c
@@ -511,9 +511,6 @@ IotEngine(
 {
 	PSTA_INFO_T pstat = NULL;
 	u4Byte i;
-#ifdef SW_TX_QUEUE
-	int swqd = priv->pshare->swq_decision;
-#endif	
 #ifdef WIFI_WMM
 	unsigned int switch_turbo = 0, avg_tp;
 #endif	
@@ -829,81 +826,130 @@ IotEngine(
 		}
 #endif
 
-#if defined(CONFIG_WLAN_HAL_8881A) || defined(CONFIG_WLAN_HAL_8192EE) || defined(CONFIG_RTL_8812_SUPPORT) || defined(CONFIG_WLAN_HAL_8814AE)
-		if ((GET_CHIP_VER(priv) == VERSION_8188E) || (assoc_num > 9))
-#endif
-		{
-		if((priv->ext_stats.tx_avarage>>17)>TP_HIGH_WATER_MARK /*|| (priv->ext_stats.rx_avarage>>17)> TP_HIGH_WATER_MARK*/) {
-			if ((priv->pshare->swq_decision == 0)){
-				switch_turbo++;
-
-				if (pstat) {
-					if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
-						priv->pshare->txop_enlarge = 0xe;
-					else if (pstat->IOTPeer==HT_IOT_PEER_RALINK)
-						priv->pshare->txop_enlarge = 0xd;
-					else if (pstat->IOTPeer==HT_IOT_PEER_HTC)
-						priv->pshare->txop_enlarge = 0;		
-					else
-						priv->pshare->txop_enlarge = 2;				
-
-				} else if (priv->pshare->txop_enlarge == 0) {
-					priv->pshare->txop_enlarge = 2;
-				}
-				priv->pshare->swq_decision = 1;
-			}
-		}
-		else{
-	       		if (priv->pshare->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd){
-					if ((priv->pshare->swq_decision == 0)){
-						switch_turbo++;
-						if (priv->pshare->txop_enlarge == 0)
-							priv->pshare->txop_enlarge = 2;
-						priv->pshare->swq_decision = 1;
-					}
-					else
-					{
-						if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
-						{
-							priv->pshare->txop_enlarge = 2;
-							switch_turbo--;
-						}
-					}
-				}
-				else if(priv->pshare->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd){
-					priv->pshare->swq_decision = 0;
-				}
-				else if ((priv->pshare->swq_decision == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0)){
-					priv->pshare->txop_enlarge = 2;
-					switch_turbo--;
-				}
-	    	} 
-
+        if((priv->ext_stats.tx_avarage>>17)>TP_HIGH_WATER_MARK) {
+            if ((priv->pshare->txop_decision == 0)){
+                switch_turbo++;
 
-			}
+                if (pstat) {
+                    if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
+                        priv->pshare->txop_enlarge = 0xe;
+                    else if (pstat->IOTPeer==HT_IOT_PEER_RALINK)
+                        priv->pshare->txop_enlarge = 0xd;
+                    else if (pstat->IOTPeer==HT_IOT_PEER_HTC)
+                        priv->pshare->txop_enlarge = 0;		
+                    else
+                        priv->pshare->txop_enlarge = 2;				
+
+                } else if (priv->pshare->txop_enlarge == 0) {
+                    priv->pshare->txop_enlarge = 2;
+                }
+                priv->pshare->txop_decision = 1;
+            }
+        }
+        else{
+            if (priv->pshare->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd){
+                if ((priv->pshare->txop_decision == 0)){
+                    switch_turbo++;
+                    if (priv->pshare->txop_enlarge == 0) {
+                        if( assoc_num < 10)
+                            priv->pshare->txop_enlarge = 2;
+                        else
+                            priv->pshare->txop_enlarge = 1;
+                    }
+                    priv->pshare->txop_decision = 1;
+                }
+                else
+                {
+                    if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
+                    {
+                        if( assoc_num < 10)
+                            priv->pshare->txop_enlarge = 2;
+                        else
+                            priv->pshare->txop_enlarge = 1;
+
+                        switch_turbo--;
+                    }
+                }
+            }
+            else if(priv->pshare->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd){
+                priv->pshare->txop_decision = 0;
+            }
+            else if ((priv->pshare->txop_decision == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0)){
+                if( assoc_num < 10)
+                    priv->pshare->txop_enlarge = 2;
+                else
+                    priv->pshare->txop_enlarge = 1;
+                switch_turbo--;
+            }
+        } 			
 
-			if( swqd ^priv->pshare->swq_decision ) {
-				if((priv->pshare->swq_decision == 1) 
-#if (defined(TX_EARLY_MODE))		
-				|| (GET_EM_SWQ_ENABLE == 1) 
-#endif		
-				) {
-					priv->pshare->swq_en = 1;
-					priv->pshare->swqen_keeptime = priv->up_time;
-	
-					extern void init_STA_SWQAggNum(struct rtl8192cd_priv *priv);
-					init_STA_SWQAggNum(priv);	
+        if(priv->pshare->rf_ft_var.swq_enable == 0) {
+            priv->pshare->swq_en = 0;
+        }
+        else {
+            if(priv->pshare->swq_en == 0) {
+                if(priv->pshare->swq_use_hw_timer) { /* new SWQ*/
+                    priv->pshare->swq_en = 1;
+                }
+                else { /* Old SWQ, check TP and tx mac change*/
+                    if((priv->ext_stats.tx_avarage>>17) > TP_HIGH_WATER_MARK ||
+                        priv->pshare->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd) {
+                        priv->pshare->swq_en = 1;
+                    }      
+
+                    #if (DM_ODM_SUPPORT_TYPE==ODM_AP) && defined(TX_EARLY_MODE)		
+                    if (GET_EM_SWQ_ENABLE == 1)
+                        priv->pshare->swq_en = 1;
+                    #endif                       
+                }
+                                            
+                if(priv->pshare->swq_en == 1) {
+                    priv->pshare->swqen_keeptime = priv->up_time;
+                    init_STA_SWQAggNum(priv);
+                }
+            }
+            else {
+                if(priv->pshare->swq_use_hw_timer == 0) {   /*Old SWQ, check TP and tx mac change*/  
+                    if((priv->ext_stats.tx_avarage>>17) <= TP_HIGH_WATER_MARK && 
+                        priv->pshare->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd
+                        #if (DM_ODM_SUPPORT_TYPE==ODM_AP) && defined(TX_EARLY_MODE)     
+                        && (GET_EM_SWQ_ENABLE == 0)
+                        #endif 
+                    ){
+                        priv->pshare->swq_en = 0;
+                    }
+                }
+                
+            }
 
-				} else {
-					priv->pshare->swq_en = 0;
-					priv->pshare->swqen_keeptime = 0;
-				}
+        }
+    
+    }
+    else {
+        priv->pshare->swq_en = 0;
+    }
+#if defined(MCR_WIRELESS_EXTEND) && !defined(WMM_DSCP_C42)
+		if (GET_CHIP_VER(priv) == VERSION_8814A) {
+			if (assoc_num > 9) {
+				priv->pshare->swq_en = 1;
+				priv->pshare->swqen_keeptime = priv->up_time;		
+				extern void init_STA_SWQAggNum(struct rtl8192cd_priv *priv);
+				init_STA_SWQAggNum(priv);	
+			} else {
+				priv->pshare->swq_en = 0;
+				priv->pshare->swqen_keeptime = 0;
 			}
-		}
+		} 
+#endif
 		if(priv->pshare->rf_ft_var.swq_enable == 0) {
 			priv->pshare->swq_en = 0;
 			priv->pshare->swqen_keeptime = 0;
-		}
+		} else if (priv->pshare->rf_ft_var.swq_enable == 2) {
+			priv->pshare->swq_en = 1;
+			priv->pshare->swqen_keeptime = priv->up_time;		
+			extern void init_STA_SWQAggNum(struct rtl8192cd_priv *priv);
+			init_STA_SWQAggNum(priv);	
+		}	
 #endif
 
 #ifdef WIFI_WMM
diff --git a/driver/rtl8192cd/WlanHAL/HalDef.h b/driver/rtl8192cd/WlanHAL/HalDef.h
index 9076243..da24820 100755
--- a/driver/rtl8192cd/WlanHAL/HalDef.h
+++ b/driver/rtl8192cd/WlanHAL/HalDef.h
@@ -200,6 +200,8 @@ typedef enum _HAL_INT_TYPE
 	HAL_INT_TYPE_TXFOVW,            // Transmit packet buffer Overflow.
 	HAL_INT_TYPE_RXERR,             // Rx Error Flag INT Status
 	HAL_INT_TYPE_TXERR,             // Tx Error Flag INT Status
+	HAL_INT_TYPE_GTIMER4,           // Gtimer 4.
+
 #if CFG_HAL_TX_AMSDU == 1 || defined(P2P_SUPPORT)
 	HAL_INT_TYPE_FS_TIMEOUT0,
 #endif	
diff --git a/driver/rtl8192cd/WlanHAL/RTL88XX/Hal88XXIsr.c b/driver/rtl8192cd/WlanHAL/RTL88XX/Hal88XXIsr.c
index e244031..e0bf5a3 100755
--- a/driver/rtl8192cd/WlanHAL/RTL88XX/Hal88XXIsr.c
+++ b/driver/rtl8192cd/WlanHAL/RTL88XX/Hal88XXIsr.c
@@ -172,6 +172,10 @@ GetInterrupt88XX(
 		bResult = (pHalData->IntArray[0] & BIT_BCNDMAINT0) ? TRUE : FALSE;
 		break;
 		
+	case HAL_INT_TYPE_GTIMER4:
+		bResult = (pHalData->IntArray[0] & BIT_GTINT4) ? TRUE : FALSE;
+		break;
+		
 	case HAL_INT_TYPE_PSTIMEOUT:
 		bResult = (pHalData->IntArray[0] & BIT_PSTIMEOUT) ? TRUE : FALSE;
 		break;
@@ -429,6 +433,10 @@ AddInterruptMask88XX(
             pHalData->IntMask[0] |= BIT_TXBCN0ERR;
     		break;
     		
+        case HAL_INT_TYPE_GTIMER4:
+            pHalData->IntMask[0] |= BIT_GTINT4;
+            break;
+
     	case HAL_INT_TYPE_BcnInt:
     		pHalData->IntMask[0] |= BIT_BCNDMAINT0;
     		break;
@@ -580,6 +588,10 @@ RemoveInterruptMask88XX(
             pHalData->IntMask[0] &= ~BIT_TXBCN0ERR;
     		break;
     		
+        case HAL_INT_TYPE_GTIMER4:
+            pHalData->IntMask[0] &= ~BIT_GTINT4;
+            break;
+
     	case HAL_INT_TYPE_BcnInt:
     		pHalData->IntMask[0] &= ~BIT_BCNDMAINT0;
     		break;
-- 
2.11.1

