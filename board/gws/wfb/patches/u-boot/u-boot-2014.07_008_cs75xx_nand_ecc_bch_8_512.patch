From 178ee290cecd1eade90abecb6cbc2af37e2fa183 Mon Sep 17 00:00:00 2001
From: Hoang Tran <hoang.tran@greenwavereality.com>
Date: Tue, 25 Aug 2015 18:00:23 -0700
Subject: [PATCH] cs75xx nand ecc BCH 8/512 support

Signed-off-by: Hoang Tran <hoang.tran@greenwavereality.com>
---
 drivers/mtd/nand/cs75xx_nand.c | 195 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 194 insertions(+), 1 deletion(-)

diff --git a/drivers/mtd/nand/cs75xx_nand.c b/drivers/mtd/nand/cs75xx_nand.c
index d15193e..b2265dd 100644
--- a/drivers/mtd/nand/cs75xx_nand.c
+++ b/drivers/mtd/nand/cs75xx_nand.c
@@ -42,6 +42,23 @@ struct cs75xx_nand_host {
 static struct cs75xx_nand_host cs75xx_host;
 static struct cs75xx_nand_host *host = &cs75xx_host;
 
+#ifdef CONFIG_CS752X_NAND_ECC_HW_BCH_8_512
+static struct nand_ecclayout oob_64_bch_8_512 = {
+	.eccbytes = 52,
+	.eccpos = {
+		   12, 13, 14, 15,
+		   16, 17, 18, 19, 20, 21, 22, 23,
+		   24, 25, 26, 27, 28, 29, 30, 31,
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 9} }
+};
+#endif
+
 FLASH_TYPE_t			flash_type;
 FLASH_STATUS_t			flash_status;
 FLASH_NF_ACCESS_t		nf_access;
@@ -56,7 +73,21 @@ FLASH_NF_ECC_STATUS_t		ecc_sts;
 FLASH_NF_ECC_CONTROL_t		ecc_ctl;
 FLASH_NF_ECC_OOB_t		ecc_oob;
 FLASH_NF_ECC_GEN0_t		ecc_gen0;
+FLASH_NF_BCH_STATUS_t		bch_sts;
+FLASH_NF_BCH_ERROR_LOC01_t	bch_err_loc01;
+FLASH_NF_BCH_ERROR_LOC23_t	bch_err_loc23;
+FLASH_NF_BCH_ERROR_LOC45_t	bch_err_loc45;
+FLASH_NF_BCH_ERROR_LOC67_t	bch_err_loc67;
 FLASH_NF_BCH_CONTROL_t		bch_ctrl;
+FLASH_NF_BCH_OOB0_t		bch_oob0;
+FLASH_NF_BCH_OOB1_t		bch_oob1;
+FLASH_NF_BCH_OOB2_t		bch_oob2;
+FLASH_NF_BCH_OOB3_t		bch_oob3;
+FLASH_NF_BCH_OOB4_t		bch_oob4;
+FLASH_NF_BCH_GEN0_0_t		bch_gen00;
+FLASH_NF_BCH_GEN0_1_t		bch_gen01;
+FLASH_NF_BCH_GEN0_2_t		bch_gen02;
+FLASH_NF_BCH_GEN0_3_t		bch_gen03;
 FLASH_NF_FIFO_CONTROL_t		fifo_ctl;
 
 DMA_DMA_SSP_RXDMA_CONTROL_t		dma_rxdma_ctrl;
@@ -933,6 +964,10 @@ static int cs75xx_nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *ch
 
 	}
 	 **/
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	/**  jenfeng clear erase tag**/
+	*(chip->oob_poi+ chip->ecc.layout->oobfree[0].offset +  chip->ecc.layout->oobfree[0].length)= 0;
+#endif
 
 	/** dma_map_single( NULL, (void *)chip->oob_poi, mtd->oobsize,  DMA_TO_DEVICE);
 
@@ -987,7 +1022,11 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 	DMA_DMA_SSP_RXQ5_INTERRUPT_t	tmp_dma_ssp_rxq5_intsts;
 	DMA_DMA_SSP_TXQ5_INTERRUPT_t	tmp_dma_ssp_txq5_intsts;
 	FLASH_FLASH_ACCESS_START_t tmp_access;
+#if defined(CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	FLASH_NF_BCH_STATUS_t	tmp_bsc_sts;
+#else
 	FLASH_NF_ECC_STATUS_t	tmp_ecc_sts;
+#endif
 
 	check_flash_ctrl_status();
 
@@ -1004,6 +1043,13 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 	ecc_reset.bf.eccClear = 1;
 	write_flash_ctrl_reg(FLASH_NF_ECC_RESET, ecc_reset.wrd);
 
+#if defined(CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	bch_ctrl.wrd = 0;
+	bch_ctrl.bf.bchEn = BCH_ENABLE;
+	bch_ctrl.bf.bchOpcode = BCH_DECODE;
+	bch_ctrl.bf.bchErrCap = BCH_ERR_CAP_8_512;
+	write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+#else
 	ecc_ctl.wrd = 0;
 	if((eccsize-1) == NCNT_512P_DATA)
 		ecc_ctl.bf.eccGenMode = ECC_GEN_512;
@@ -1011,6 +1057,7 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 		ecc_ctl.bf.eccGenMode = ECC_GEN_256;
 	ecc_ctl.bf.eccEn = ECC_ENABLE;
 	write_flash_ctrl_reg(FLASH_NF_ECC_CONTROL, ecc_ctl.wrd);
+#endif
 
 	/*disable txq5*/
 	dma_txq5_ctrl.bf.txq5_en = 0;
@@ -1171,6 +1218,16 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 	dma_rxq5_rptr.bf.index = (dma_rxq5_rptr.bf.index + 1) % FDMA_DESC_NUM;
 	write_dma_ctrl_reg(DMA_DMA_SSP_RXQ5_RPTR, dma_rxq5_rptr.wrd);
 
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	bch_sts.wrd=read_flash_ctrl_reg(FLASH_NF_BCH_STATUS);
+
+	tmp_bsc_sts.wrd = 0;
+	tmp_bsc_sts.bf.bchGenDone = 1;
+
+	reg_wait(FLASH_NF_BCH_STATUS, tmp_bsc_sts.wrd , tmp_bsc_sts.wrd, 1000);
+
+	/**write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, 0);  **/
+#else
 	ecc_sts.wrd=read_flash_ctrl_reg(FLASH_NF_ECC_STATUS);
 
 	tmp_ecc_sts.wrd = 0;
@@ -1181,9 +1238,17 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 	ecc_ctl.wrd = read_flash_ctrl_reg(FLASH_NF_ECC_CONTROL );  /**disable ecc gen**/
 	ecc_ctl.bf.eccEn = 0;
 	write_flash_ctrl_reg(FLASH_NF_ECC_CONTROL, ecc_ctl.wrd);  /**disable ecc gen**/
+#endif
 	/**dma_cache_maint((void *)chip->oob_poi, mtd->oobsize, DMA_FROM_DEVICE);
 	dma_cache_maint((void *)buf, mtd->writesize, DMA_FROM_DEVICE);
 	**/
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	/** jenfeng**/
+        if( 0xff ==  *(chip->oob_poi+ chip->ecc.layout->oobfree[0].offset +  chip->ecc.layout->oobfree[0].length)){
+                /** Erase tga is on , No needs to check. **/
+                goto BCH_EXIT;
+        }
+#endif
 
 	for (i = 0; i < chip->ecc.total; i++)
 		ecc_code[i] = chip->oob_poi[eccpos[i]];
@@ -1193,6 +1258,68 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 		  printf(" %x", ecc_code[i]);
 	**/
 	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+		int j ; /** (i/eccbytes);**/
+
+		bch_oob0.wrd = ecc_code[i]   | ecc_code[i+1]<<8 | ecc_code[i+2]<<16  | ecc_code[i+3]<<24;
+		bch_oob1.wrd = ecc_code[i+4] | ecc_code[i+5]<<8 | ecc_code[i+6]<<16  | ecc_code[i+7]<<24;
+		bch_oob2.wrd = ecc_code[i+8] | ecc_code[i+9]<<8 | ecc_code[i+10]<<16 | ecc_code[i+11]<<24;
+		bch_oob3.wrd = ecc_code[i+12];
+
+		write_flash_ctrl_reg(FLASH_NF_BCH_OOB0, bch_oob0.wrd);
+		write_flash_ctrl_reg(FLASH_NF_BCH_OOB1, bch_oob1.wrd);
+		write_flash_ctrl_reg(FLASH_NF_BCH_OOB2, bch_oob2.wrd);
+		write_flash_ctrl_reg(FLASH_NF_BCH_OOB3, bch_oob3.wrd);
+
+		/** enable ecc compare**/
+		bch_ctrl.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_CONTROL);
+		bch_ctrl.bf.bchCodeSel = (i/eccbytes);
+		bch_ctrl.bf.bchCompare = 1;
+		write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+
+		tmp_bsc_sts.wrd = 0;
+		tmp_bsc_sts.bf.bchDecDone = 1;
+
+		reg_wait(FLASH_NF_BCH_STATUS, tmp_bsc_sts.wrd , tmp_bsc_sts.wrd, 1000);
+
+		bch_sts.wrd=read_flash_ctrl_reg(FLASH_NF_BCH_STATUS);
+
+		switch(bch_sts.bf.bchDecStatus)
+		{
+		case BCH_CORRECTABLE_ERR:
+			//printf("correctable error(%x)!!\n",bch_sts.bf.bchErrNum);
+			for(j=0  ;j<((bch_sts.bf.bchErrNum+1)/2);j++)
+			{
+				bch_err_loc01.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_ERROR_LOC01 + j*4);
+
+				if ( (j+1)*2 <= bch_sts.bf.bchErrNum ) {
+					if( ((bch_err_loc01.bf.bchErrLoc1 & 0x1fff)>>3) < 0x200) {
+						p[(bch_err_loc01.bf.bchErrLoc1&0x1fff)>>3] ^= (1 << (bch_err_loc01.bf.bchErrLoc1 & 0x07));
+					}
+				}
+
+				if(((bch_err_loc01.bf.bchErrLoc0 & 0x1fff)>>3) < 0x200) {
+					p[(bch_err_loc01.bf.bchErrLoc0&0x1fff)>>3] ^= (1 << (bch_err_loc01.bf.bchErrLoc0 & 0x07));
+				}
+			}
+			break;
+		case BCH_UNCORRECTABLE:
+			printf("uncorrectable error!!\n");
+			mtd->ecc_stats.failed++;
+
+			break;
+		}
+		/** clear compare sts
+		  bch_sts.bf.bchDecDone = 0;
+		  write_flash_ctrl_reg(FLASH_NF_BCH_STATUS, bch_sts.wrd);
+		 **/
+
+		/** disable ecc compare**/
+		bch_ctrl.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_CONTROL);
+		bch_ctrl.bf.bchCompare = 0;
+		write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+#else
 		ecc_oob.wrd =	ecc_code[i] | ecc_code[i+1]<<8 | ecc_code[i+2]<<16;
 		write_flash_ctrl_reg(FLASH_NF_ECC_OOB, ecc_oob.wrd);
 
@@ -1235,9 +1362,16 @@ static int cs75xx_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *c
 				printf("\nECC uncorrectable error(%x)!!(org: %x) HW(%xs) page(%x)\n", (i/eccbytes), ecc_oob.wrd, ecc_gen0.wrd, page);
 				break;
 		}
-
+#endif
 	}
 
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+BCH_EXIT:
+	/** diasble bch **/
+	bch_ctrl.wrd = 0;
+	write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+#endif
+
 	return 0;
 }
 
@@ -1254,7 +1388,11 @@ static int cs75xx_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *
 	DMA_DMA_SSP_RXQ5_INTERRUPT_t	tmp_dma_ssp_rxq5_intsts;
 	DMA_DMA_SSP_TXQ5_INTERRUPT_t	tmp_dma_ssp_txq5_intsts;
 	FLASH_FLASH_ACCESS_START_t 	tmp_access;
+#if defined(CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	FLASH_NF_BCH_STATUS_t		tmp_bsc_sts;
+#else
 	FLASH_NF_ECC_STATUS_t		tmp_ecc_sts;
+#endif
 
 	check_flash_ctrl_status();
 
@@ -1272,6 +1410,13 @@ static int cs75xx_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *
 	ecc_reset.bf.eccClear = 1;
 	write_flash_ctrl_reg(FLASH_NF_ECC_RESET, ecc_reset.wrd);
 
+#if defined(CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	bch_ctrl.wrd = 0;
+	bch_ctrl.bf.bchEn = BCH_ENABLE;
+	bch_ctrl.bf.bchErrCap = BCH_ERR_CAP_8_512;
+	bch_ctrl.bf.bchOpcode = BCH_ENCODE;
+	write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+#else
 	ecc_ctl.wrd = 0;
 	if((eccsize-1) == NCNT_512P_DATA)
 		ecc_ctl.bf.eccGenMode = ECC_GEN_512;
@@ -1279,6 +1424,7 @@ static int cs75xx_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *
 		ecc_ctl.bf.eccGenMode = ECC_GEN_256;
 	ecc_ctl.bf.eccEn = ECC_ENABLE;
 	write_flash_ctrl_reg(FLASH_NF_ECC_CONTROL, ecc_ctl.wrd);
+#endif
 
 	/*disable txq5*/
 	dma_txq5_ctrl.bf.txq5_en = 0;
@@ -1407,6 +1553,17 @@ static int cs75xx_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *
 	dma_ssp_rxq5_intsts.bf.rxq5_eof = 0;
 	write_dma_ctrl_reg(DMA_DMA_SSP_RXQ5_INTERRUPT, dma_ssp_rxq5_intsts.wrd);
 
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	bch_sts.wrd=read_flash_ctrl_reg(FLASH_NF_BCH_STATUS);
+	tmp_bsc_sts.wrd = 0;
+	tmp_bsc_sts.bf.bchGenDone = 1;
+
+	reg_wait(FLASH_NF_BCH_STATUS, tmp_bsc_sts.wrd , tmp_bsc_sts.wrd, 1000);
+
+	bch_ctrl.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_CONTROL);  /*disable ecc gen*/
+	bch_ctrl.bf.bchEn = BCH_DISABLE;
+	write_flash_ctrl_reg(FLASH_NF_BCH_CONTROL, bch_ctrl.wrd);
+#else
 	ecc_sts.wrd=read_flash_ctrl_reg(FLASH_NF_ECC_STATUS);
 	tmp_ecc_sts.wrd = 0;
 	tmp_ecc_sts.bf.eccDone = 1;
@@ -1416,14 +1573,38 @@ static int cs75xx_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *
 	ecc_ctl.wrd = read_flash_ctrl_reg( FLASH_NF_ECC_CONTROL);
 	ecc_ctl.bf.eccEn= 0;
 	write_flash_ctrl_reg(FLASH_NF_ECC_CONTROL, ecc_ctl.wrd);  /*disable ecc gen*/
+#endif
 
 	for (i = 0,j = 0; eccsteps; eccsteps--, i++, j += eccbytes) {
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+		bch_gen00.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_GEN0_0 + 20*i);
+		chip->oob_poi[eccpos[j]] = bch_gen00.wrd & 0xff;
+		chip->oob_poi[eccpos[j+1]] = (bch_gen00.wrd >> 8) & 0xff;
+		chip->oob_poi[eccpos[j+2]] = (bch_gen00.wrd >> 16) & 0xff;
+		chip->oob_poi[eccpos[j+3]] = (bch_gen00.wrd >> 24) & 0xff;
+		bch_gen01.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_GEN0_1 + 20*i);
+		chip->oob_poi[eccpos[j+4]] = bch_gen01.wrd & 0xff;
+		chip->oob_poi[eccpos[j+5]] = (bch_gen01.wrd >> 8) & 0xff;
+		chip->oob_poi[eccpos[j+6]] = (bch_gen01.wrd >> 16) & 0xff;
+		chip->oob_poi[eccpos[j+7]] = (bch_gen01.wrd >> 24) & 0xff;
+		bch_gen02.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_GEN0_2 + 20*i);
+		chip->oob_poi[eccpos[j+8]] = bch_gen02.wrd & 0xff;
+		chip->oob_poi[eccpos[j+9]] = (bch_gen02.wrd >> 8) & 0xff;
+		chip->oob_poi[eccpos[j+10]] = (bch_gen02.wrd >> 16) & 0xff;
+		chip->oob_poi[eccpos[j+11]] = (bch_gen02.wrd >> 24) & 0xff;
+		bch_gen03.wrd = read_flash_ctrl_reg(FLASH_NF_BCH_GEN0_3 + 20*i);
+		chip->oob_poi[eccpos[j+12]] = bch_gen03.wrd & 0xff;
+#else
 		ecc_gen0.wrd = read_flash_ctrl_reg(FLASH_NF_ECC_GEN0 + 4*i);
 		chip->oob_poi[eccpos[j]] = ecc_gen0.wrd & 0xff;
 		chip->oob_poi[eccpos[j+1]] = (ecc_gen0.wrd >> 8) & 0xff;
 		chip->oob_poi[eccpos[j+2]] = (ecc_gen0.wrd >> 16) & 0xff;
+#endif
 	}
 
+#if defined( CONFIG_CS752X_NAND_ECC_HW_BCH_8_512)
+	*(chip->oob_poi+ chip->ecc.layout->oobfree[0].offset +  chip->ecc.layout->oobfree[0].length)= 0;
+#endif
 	/*dma_map_single( NULL, (void *)chip->oob_poi, mtd->oobsize, DMA_TO_DEVICE);
 
 	dma_txq5_wptr.wrd = read_dma_ctrl_reg(DMA_DMA_SSP_TXQ5_WPTR);
@@ -1692,9 +1873,21 @@ int board_nand_init(struct nand_chip *nand)
 	nand->select_chip = cs75xx_nand_select_chip;
 	nand->read_byte = cs75xx_nand_read_byte;
 
+#ifdef CONFIG_SYS_NAND_SUBPAGE_SIZE
+	nand->subpagesize = CONFIG_SYS_NAND_SUBPAGE_SIZE;
+#endif
+#ifdef CONFIG_SYS_NAND_NO_SUBPAGE_WRITE
+	nand->options |= NAND_NO_SUBPAGE_WRITE;
+#endif
 	nand->ecc.mode = NAND_ECC_HW;
+#ifdef CONFIG_CS752X_NAND_ECC_HW_BCH_8_512
+	nand->ecc.size = 512;
+	nand->ecc.bytes = 13;
+	nand->ecc.layout= &oob_64_bch_8_512;
+#else
 	nand->ecc.size = 256;
 	nand->ecc.bytes = 3;
+#endif
 	nand->ecc.strength = 1;
 
 	nand->ecc.calculate = cs75xx_nand_calculate_ecc;
-- 
2.6.1

