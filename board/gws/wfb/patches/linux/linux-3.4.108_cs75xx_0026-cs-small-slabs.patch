diff -ruN a/drivers/net/ethernet/cs752x/Kconfig b/drivers/net/ethernet/cs752x/Kconfig
--- a/drivers/net/ethernet/cs752x/Kconfig	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/Kconfig	2016-01-20 14:57:03.456510509 +0100
@@ -548,4 +548,12 @@
           It provides another way to receive rx packets.
           If this option is set, the throught will be down
 
+config CS75XX_SMALL_SLAB
+	bool "Provide individual slab for small memory allocation"
+	default n
+        depends on CS752X
+	---help---
+	  This only occurs when the memory allocation is equal or smaller than 16 bytes.
+	  Enable this to reduce memory usage in Cortina NE.
+
 endif
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_core_fastnet.c b/drivers/net/ethernet/cs752x/src/core/cs_core_fastnet.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_core_fastnet.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_core_fastnet.c	2016-01-20 14:57:03.456510509 +0100
@@ -34,7 +34,7 @@
 #include "cs_core_fastnet.h"
 #include "cs_hmu.h"
 #include "cs752x_eth.h"
-
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -85,7 +85,7 @@
 				    list_entry(pos, cs_fastnet_hash_table_t,
 					       list);
 				list_del_init(&entry->list);
-				kfree(entry);
+				cs_free(entry);
 
 			}
 		}
@@ -741,7 +741,7 @@
 	if (list_empty(table)) {
 		entry =
 		    (cs_fastnet_hash_table_t *)
-		    kzalloc(sizeof(cs_fastnet_hash_table_t), GFP_ATOMIC);
+		    cs_zalloc(sizeof(cs_fastnet_hash_table_t), GFP_ATOMIC);
 		if (entry == NULL) {
 			DBG(printk
 			    ("%s no more memory - alloc memory fail \n",
@@ -886,7 +886,7 @@
 			DBG(printk("\t %s delete fastnet entry@%x\n", __func__,
 						(u32)entry));
 			list_del_init(&entry->list);
-			kfree(entry);
+			cs_free(entry);
 		}
 	}
 	spin_unlock(&cs_fastnet_hash_base_lock);
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_core_hmu.c b/drivers/net/ethernet/cs752x/src/core/cs_core_hmu.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_core_hmu.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_core_hmu.c	2016-01-20 14:57:03.456510509 +0100
@@ -21,6 +21,7 @@
 #include "cs_hmu.h"
 #include "cs_core_hmu.h"
 #include "cs_fe.h"
+#include "cs_mut.h"
 
 #define PFX     "CS_CORE_HMU"
 #define PRINT(format, args...) printk(KERN_WARNING PFX \
@@ -484,7 +485,7 @@
 		return NULL;
 	}
 
-	key = (u8 *)kzalloc(len, GFP_ATOMIC);
+	key = (u8 *) cs_zalloc(len, GFP_ATOMIC);
 	if (key == NULL) {
 		DBG(PRINT("No memory for key, len = %d\n", len));
 		return NULL;
@@ -546,15 +547,15 @@
 					(0x1 << i));
 			if (curr_value != NULL) {
 				if (last_value == NULL) {
-					last_value = new_value = kmalloc(
+					last_value = new_value = cs_malloc(
 						sizeof(cs_core_hmu_value_t),
-						GFP_ATOMIC);
+						GFP_ATOMIC);
 					if (last_value == NULL)
 						goto EXIT_FREE_ALL;
 				} else {
-					last_value->next = kmalloc(
+					last_value->next = cs_malloc(
 						sizeof(cs_core_hmu_value_t),
-						GFP_ATOMIC);
+						GFP_ATOMIC);
 					if (last_value->next == NULL)
 						goto EXIT_FREE_ALL;
 					last_value = last_value->next;
@@ -570,7 +571,7 @@
 	if (new_value != NULL) {
 		do {
 			curr_value = new_value->next;
-			kfree(new_value);
+			cs_free(new_value);
 			new_value = curr_value;
 		} while (new_value != NULL);
 	}
@@ -587,14 +588,14 @@
 	v = int_core_hmu->value_mask;
 	while (v != NULL) {
 		tmp = v->next;
-		kfree(v);
+		cs_free(v);
 		v = tmp;
 	}
 
 	if (int_core_hmu->mask_in_str != NULL)
-		kfree(int_core_hmu->mask_in_str);
+		cs_free(int_core_hmu->mask_in_str);
 
-	kfree(int_core_hmu);
+	cs_free(int_core_hmu);
 }
 
 static int insert_new_core_hmu_to_list(cs_core_hmu_t *hmu_entry,
@@ -615,8 +616,8 @@
 	}
 
 	/* create new internal HMU table node */
-	curr = (cs_core_hmu_int_t *)kzalloc(sizeof(cs_core_hmu_int_t),
-			GFP_ATOMIC);
+	curr = (cs_core_hmu_int_t *) cs_zalloc(sizeof(cs_core_hmu_int_t),
+			GFP_ATOMIC);
 	if (curr == NULL) {
 		DBG(PRINT("internal core HMU table allocation failed\n"));
 		return -ENOMEM;
@@ -641,9 +642,9 @@
 	INIT_LIST_HEAD(&curr->callback_func_list);
 	curr->callback_func_cnt = 0;
 	if (hmu_entry->callback) {
-		cbk = (cs_core_hmu_callback_list_t *)kmalloc(
+		cbk = (cs_core_hmu_callback_list_t *) cs_malloc(
 				sizeof(cs_core_hmu_callback_list_t),
-				GFP_ATOMIC);
+				GFP_ATOMIC);
 		if (cbk == NULL) {
 			DBG(PRINT("callback list allocation failed!\n"));
 			free_core_hmu_int(curr);
@@ -698,12 +699,12 @@
 		if ((curr->str_size == tmp_key_size) &&
 			(curr->watch_bitmask == hmu_entry->watch_bitmask) &&
 			(memcmp(curr->mask_in_str, tmp_key, tmp_key_size) == 0)) {
-			kfree(tmp_key);
+			cs_free(tmp_key);
 			return curr;
 		}
 		curr = curr->next;
 	}
-	kfree(tmp_key);
+	cs_free(tmp_key);
 	return NULL;
 } /* find_core_hmu_node */
 
@@ -740,7 +741,7 @@
 	cs_core_hmu_value_t *new_value;
 	u16 swid_mod;
 
-	new_value = kzalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
+	new_value = cs_zalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
 	if (new_value == NULL)
 		return NULL;
 	switch (type) {
@@ -770,12 +771,12 @@
 
 	case CS_CORE_HMU_WATCH_SWID64:
 		if (mask_val == NULL) {
-			kfree(new_value);
+			cs_free(new_value);
 			return NULL;
 		}
 		swid_mod = (u16)CS_SWID64_TO_MOD_ID(mask_val->value.swid64);
 		if (swid_mod >= CS_SWID64_MOD_MAX) {
-			kfree(new_value);
+			cs_free(new_value);
 			return NULL;
 		}
 		new_value->type = type;
@@ -827,7 +828,7 @@
 EXIT_FREE_ALLOCATED:
 	while (ret_value != NULL) {
 		new_value = ret_value->next;
-		kfree(ret_value);
+		cs_free(ret_value);
 		ret_value = new_value;
 	}
 
@@ -878,7 +879,7 @@
 
 	while (ret_hmu_value != NULL) {
 		next_hmu_value = ret_hmu_value->next;
-		kfree(ret_hmu_value);
+		cs_free(ret_hmu_value);
 		ret_hmu_value = next_hmu_value;
 	};
 
@@ -948,9 +949,9 @@
 	watch = find_core_hmu_node(hmu_entry);
 	if (watch != NULL) {
 		if (hmu_entry->callback) {
-			cbk = (cs_core_hmu_callback_list_t *)kmalloc(
+			cbk = (cs_core_hmu_callback_list_t *) cs_malloc(
 					sizeof(cs_core_hmu_callback_list_t),
-					GFP_ATOMIC);
+					GFP_ATOMIC);
 			if (cbk == NULL) {
 				DBG(PRINT("callback list allocation fails!\n"));
 				return -ENOMEM;
@@ -993,7 +994,7 @@
 	list_for_each_entry_safe(cb_node, c, &curr->callback_func_list, node) {
 		if (cb_node->callback == hmu_entry->callback) {
 			list_del(&cb_node->node);
-			kfree(cb_node);
+			cs_free(cb_node);
 			curr->callback_func_cnt--;
 		}
 	}
@@ -1064,7 +1065,7 @@
 		return -EPERM;
 	}
 	ret = cs_hmu_del_hash_by_src(curr->hmu_table, (unsigned char *)key);
-	kfree(key);
+	cs_free(key);
 
 	return ret;
 } /* cs_core_hmu_delete_hash */
@@ -1107,7 +1108,7 @@
 	}
 	ret = cs_hmu_get_last_use_by_src(curr->hmu_table,
 			(unsigned char *)key, time_in_jiffies);
-	kfree(key);
+	cs_free(key);
 
 	if (ret) {
 		DBG(PRINT("Can't get the last used jiffies, ret = %d\n", ret));
@@ -1689,7 +1690,7 @@
 		return NULL;
 	}
 
-	key = (u8 *)kzalloc(len, GFP_ATOMIC);
+	key = (u8 *) cs_zalloc(len, GFP_ATOMIC);
 	if (key == NULL) {
 		DBG(PRINT("No memory for key, len = %d\n", len));
 		return NULL;
@@ -1703,7 +1704,7 @@
 				ret = masked_cb_to_sub_key(key + offset,
 						cb, type, NULL, check_mask);
 				if (ret <= 0) {
-					kfree(key);
+					cs_free(key);
 					return NULL;
 				}
 				offset += ret;
@@ -1718,7 +1719,7 @@
 							key + offset, cb, type,
 							curr, check_mask);
 					if (ret <= 0) {
-						kfree(key);
+						cs_free(key);
 						return NULL;
 					}
 					offset += ret;
@@ -1729,7 +1730,7 @@
 							key + offset, cb, type,
 							NULL, check_mask);
 					if (ret <= 0) {
-						kfree(key);
+						cs_free(key);
 						return NULL;
 					}
 					offset += ret;
@@ -1758,16 +1759,16 @@
 		//		"0x%p, size = %d\n", curr->watch_bitmask,
 		//		cb_key, key_size));
 		if (cb_key)
-			kfree(cb_key);
+			cs_free(cb_key);
 		return false;
 	}
 
 	if (memcmp(curr->mask_in_str, cb_key, key_size) == 0) {
-		kfree(cb_key);
+		cs_free(cb_key);
 		return true;
 	}
 
-	kfree(cb_key);
+	cs_free(cb_key);
 	return false;
 }
 
@@ -1801,7 +1802,7 @@
 				if (ret != 0)
 					DBG(PRINT("Failed to link SRC and "
 								"hash\n"));
-				kfree(key);
+				cs_free(key);
 			}
 		}
 		curr = curr->next;
@@ -1824,7 +1825,7 @@
 
 	ret_hmu_value = construct_core_hmu_value_from_string(int_data, key);
 	if (ret_hmu_value == NULL) {
-		kfree(key);
+		cs_free(key);
 		return;
 	}
 
@@ -1837,11 +1838,11 @@
 
 	while (ret_hmu_value != NULL) {
 		next_hmu_value = ret_hmu_value->next;
-		kfree(ret_hmu_value);
+		cs_free(ret_hmu_value);
 		ret_hmu_value = next_hmu_value;
 	};
 
-	kfree(key);
+	cs_free(key);
 
 	return;
 }
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_core_mcu.c b/drivers/net/ethernet/cs752x/src/core/cs_core_mcu.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_core_mcu.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_core_mcu.c	2016-01-20 14:57:03.456510509 +0100
@@ -37,6 +37,7 @@
 #include "cs_core_rule_hmu.h"
 #include "cs752x_eth.h"
 #include <mach/cs_mcast.h>
+#include "cs_mut.h"
 #ifdef CONFIG_CS75XX_MTU_CHECK
 #include <mach/cs_mtu.h>
 extern cs_port_id_t cs_wan_port_id;
@@ -2153,7 +2154,7 @@
 	if (!cs_cb)
 		return CS_ACCEL_HASH_DONT_CARE;
 
-	fwd_hash = kzalloc(sizeof(cs_fwd_hash_t)*MAX_FWD_HASH_CNT, GFP_KERNEL);
+	fwd_hash = cs_zalloc(sizeof(cs_fwd_hash_t)*MAX_FWD_HASH_CNT, GFP_KERNEL);
 	if (!fwd_hash)
 		return CS_ACCEL_HASH_DONT_CARE;
 	memset(&qos_hash, 0, sizeof(cs_qos_hash_t));
@@ -2236,7 +2237,7 @@
 	}
 
 end:
-	kfree(fwd_hash);
+	cs_free(fwd_hash);
 	return result;
 
 FAIL_TO_ADD_HASH:
@@ -2261,7 +2262,7 @@
 		cs_core_hmu_delete_hash_by_idx(fwd_hash_idx[j]);
 	}
 	//memset(&cs_cb->hw_rslt, 0, sizeof(cb_result_index_t));
-	kfree(fwd_hash);
+	cs_free(fwd_hash);
 	return CS_ACCEL_HASH_FAIL;
 }
 
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_core_rule_hmu.c b/drivers/net/ethernet/cs752x/src/core/cs_core_rule_hmu.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_core_rule_hmu.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_core_rule_hmu.c	2016-01-20 14:57:03.456510509 +0100
@@ -21,6 +21,7 @@
 #include "cs_hmu.h"
 #include "cs_core_rule_hmu.h"
 #include "cs_fe.h"
+#include "cs_mut.h"
 
 #define PFX     "CS_CORE_RULE_HMU"
 #define PRINT(format, args...) printk(KERN_WARNING PFX \
@@ -50,14 +51,14 @@
 	v = int_core_hmu->value_mask;
 	while (v != NULL) {
 		tmp = v->next;
-		kfree(v);
+		cs_free(v);
 		v = tmp;
 	}
 
 	if (int_core_hmu->mask_in_str != NULL)
-		kfree(int_core_hmu->mask_in_str);
+		cs_free(int_core_hmu->mask_in_str);
 
-	kfree(int_core_hmu);
+	cs_free(int_core_hmu);
 #endif
 }
 
@@ -97,7 +98,7 @@
 	int ret;
 
 	ret = cs_hmu_del_hash_by_src(g_rule_hmu_table, (unsigned char *)p_data);
-	//kfree(key);
+	//cs_free(key);
 
 	return ret;
 } /* cs_core_hmu_delete_hash */
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_core_skb_cb.c b/drivers/net/ethernet/cs752x/src/core/cs_core_skb_cb.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_core_skb_cb.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_core_skb_cb.c	2016-01-20 14:57:03.456510509 +0100
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include "cs_core_logic.h"
+#include "cs_mut.h"
 
 /* after several tests, the following seems to be the best combinations:
  * SMP: define CONFIG_PER_CPU_CB_POOL, CONFIG_CB_POOL_LOCK, and
@@ -196,7 +197,7 @@
 #endif
 
 	for (i = 0; i < accel_cb_inc_size; i++) {
-		new_cb_db = kzalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
+		new_cb_db = cs_zalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
 		if (new_cb_db == NULL)
 			break;
 		new_cb_db->cpu_pool = cpu;
@@ -445,7 +446,7 @@
 #endif
 
 	for (i = 0; i < accel_cb_curr_size_0; i++) {
-		new_cb_db = kzalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
+		new_cb_db = cs_zalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
 		if (new_cb_db == NULL)
 			break;
 		new_cb_db->cpu_pool = 0;
@@ -456,7 +457,7 @@
 
 #ifdef CONFIG_PER_CPU_CB_POOL
 	for (i = 0; i < accel_cb_curr_size_1; i++) {
-		new_cb_db = kzalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
+		new_cb_db = cs_zalloc(sizeof(cs_accel_cb_db_t), GFP_ATOMIC);
 		if (new_cb_db == NULL)
 			break;
 		new_cb_db->cpu_pool = 1;
@@ -479,7 +480,7 @@
 				node);
 		list_del(&cb_db_ptr->node);
 		cb_db_ptr->skb->cs_cb_loc = 0;
-		kfree(cb_db_ptr);
+		cs_free(cb_db_ptr);
 	}
 #endif
 
@@ -487,14 +488,14 @@
 		cb_db_ptr = list_first_entry(&accel_cb_pool_0, cs_accel_cb_db_t,
 				node);
 		list_del(&cb_db_ptr->node);
-		kfree(cb_db_ptr);
+		cs_free(cb_db_ptr);
 	}
 #ifdef CONFIG_PER_CPU_CB_POOL
 	while (!list_empty(&accel_cb_pool_1)) {
 		cb_db_ptr = list_first_entry(&accel_cb_pool_1, cs_accel_cb_db_t,
 				node);
 		list_del(&cb_db_ptr->node);
-		kfree(cb_db_ptr);
+		cs_free(cb_db_ptr);
 	}
 #endif
 }
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_hmu.c b/drivers/net/ethernet/cs752x/src/core/cs_hmu.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_hmu.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_hmu.c	2016-01-20 14:57:03.456510509 +0100
@@ -20,6 +20,7 @@
 #include "cs_core_hmu.h"
 #include "cs_core_fastnet.h"
 #include "cs_fe.h"
+#include "cs_mut.h"
 
 #define PFX     "CS_HMU"
 #define PRINT(format, args...) printk(KERN_WARNING PFX \
@@ -330,7 +331,7 @@
 	//debug_Aaron
 	printk(KERN_DEBUG "%s: key_size=%d\n", __func__, key_size);
 	DBG(PRINT("Start Allocating a HMU table\n"));
-	tbl = (cs_hmu_table_t*)kzalloc(sizeof(cs_hmu_table_t), GFP_ATOMIC);
+	tbl = (cs_hmu_table_t*) cs_zalloc(sizeof(cs_hmu_table_t), GFP_ATOMIC);
 	if (!tbl) {
 		DBG(PRINT("No memory for HMU SRC table\n"));
 		return NULL;
@@ -344,11 +345,11 @@
 	tbl->callback = callback;
 
 	/* add tbl to hmu_tbl_head */
-	tbl_node = (cs_hmu_ptr_list_t *) \
-		kzalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
+	tbl_node = (cs_hmu_ptr_list_t *)
+		cs_zalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
 	if (!tbl_node) {
 		spin_unlock_bh(&hmu_lock);
-		kfree(tbl);
+		cs_free(tbl);
 		DBG(PRINT("No memory for table node\n"));
 		return NULL;
 	}
@@ -378,7 +379,7 @@
 					     cs_hmu_ptr_list_t, node);
 		hash_entry = (cs_hmu_hash_t *)hash_node->data;
 		list_del_init(&hash_node->node);
-		kfree(hash_node);
+		cs_free(hash_node);
 
 		/*
 		 * don't check contents of the hash entry
@@ -392,7 +393,7 @@
 			node) {
 			if (src_node->data == (u32)src_entry) {
 				list_del_init(&src_node->node);
-				kfree(src_node);
+				cs_free(src_node);
 				break;
 			}
 		}
@@ -414,8 +415,8 @@
 	 * The callback function should be called by caller if necessary.
 	 */
 
-	kfree(src_entry->key);
-	kfree(src_entry);
+	cs_free(src_entry->key);
+	cs_free(src_entry);
 	return 0;
 }
 
@@ -486,13 +487,13 @@
 	list_for_each_entry_safe(tmp_tbl_ptr, n, &hmu_tbl_head.node, node) {
 		if (tmp_tbl_ptr->data == (u32) table) {
 			list_del_init(&tmp_tbl_ptr->node);
-			kfree(tmp_tbl_ptr);
+			cs_free(tmp_tbl_ptr);
 			break;
 		}
 	}
 	spin_unlock_bh(&hmu_lock);
 	DBG(PRINT("Done Freeing table!\n"));
-	kfree(table);
+	cs_free(table);
 	return 0;
 }
 
@@ -521,14 +522,14 @@
 		list_del_init(&src_node->node);
 		src_entry = (cs_hmu_src_t *)src_node->data;
 		hmu_tbl = src_entry->hmu_table_ptr;
-		kfree(src_node);
+		cs_free(src_node);
 		atomic_dec(&hash_entry->hmu_usr_cnt);
 
 		/* remove link of hash_entry from src_entry */
 		list_for_each_entry(hash_node, &src_entry->hash_list, node) {
 			if (hash_node->data == (u32)hash_entry) {
 				list_del_init(&hash_node->node);
-				kfree(hash_node);
+				cs_free(hash_node);
 				atomic_dec(&src_entry->ref_cnt);
 				break;
 			}
@@ -675,26 +676,26 @@
 	}
 
 	 /* prepare hash_node and src_node */
-	hash_node = (cs_hmu_ptr_list_t *) \
-		kzalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
+	hash_node = (cs_hmu_ptr_list_t *)
+		cs_zalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
 	if (!hash_node) {
 		printk("%s: allocate hash_node failed!!\n", __func__);
 		goto ERR_0;
 	}
 
 
-	src_node = (cs_hmu_ptr_list_t *) \
-		kzalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
+	src_node = (cs_hmu_ptr_list_t *)
+		cs_zalloc(sizeof(cs_hmu_ptr_list_t), GFP_ATOMIC);
 	if (!src_node)
 		goto ERR_1;
 
 	if (src_entry == NULL) {
 		/* create new src_entry */
-		src_entry = (cs_hmu_src_t *) \
-			kzalloc(sizeof(cs_hmu_src_t), GFP_ATOMIC);
+		src_entry = (cs_hmu_src_t *)
+			cs_zalloc(sizeof(cs_hmu_src_t), GFP_ATOMIC);
 		if (!src_entry)
 			goto ERR_2;
-		src_entry->key = (u8 *)kmalloc(key_size, GFP_ATOMIC);
+		src_entry->key = (u8 *) cs_malloc(key_size, GFP_ATOMIC);
 		if (!src_entry->key)
 			goto ERR_3;
 		memcpy(src_entry->key, src_key, key_size);
@@ -733,11 +734,11 @@
 	return 0;
 
 ERR_3:
-	kfree(src_entry);
+	cs_free(src_entry);
 ERR_2:
-	kfree(src_node);
+	cs_free(src_node);
 ERR_1:
-	kfree(hash_node);
+	cs_free(hash_node);
 ERR_0:
 	spin_unlock_bh(&hmu_lock);
 	return -ENOMEM;
@@ -954,7 +955,7 @@
 		list_del_init(&src_node->node);
 		src_entry = (cs_hmu_src_t *)src_node->data;
 		hmu_tbl = src_entry->hmu_table_ptr;
-		kfree(src_node);
+		cs_free(src_node);
 		atomic_dec(&hash_entry->hmu_usr_cnt);
 
 		/* Don't cross-check involved src entries. We will handle it
@@ -966,7 +967,7 @@
 		list_for_each_entry(hash_node, &src_entry->hash_list, node) {
 			if (hash_node->data == (u32)hash_entry) {
 				list_del_init(&hash_node->node);
-				kfree(hash_node);
+				cs_free(hash_node);
 				atomic_dec(&src_entry->ref_cnt);
 				break;
 			}
@@ -1093,13 +1094,13 @@
 		hash_entry = (cs_hmu_hash_t *)hash_node->data;
 		list_del_init(&hash_node->node);
 		atomic_dec(&src_entry->ref_cnt);
-		kfree(hash_node);
+		cs_free(hash_node);
 
 		/* remove link of src_entry from hash_entry */
 		list_for_each_entry(src_node, &hash_entry->hmu_src_list, node) {
 			if (src_node->data == (u32)src_entry) {
 				list_del_init(&src_node->node);
-				kfree(src_node);
+				cs_free(src_node);
 				break;
 			}
 		}
diff -ruN a/drivers/net/ethernet/cs752x/src/core/cs_vtable.c b/drivers/net/ethernet/cs752x/src/core/cs_vtable.c
--- a/drivers/net/ethernet/cs752x/src/core/cs_vtable.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/core/cs_vtable.c	2016-01-20 14:57:03.456510509 +0100
@@ -20,7 +20,7 @@
 #include "cs_vtable.h"
 #include "cs_fe.h"
 #include "cs_fe_mc.h"
-
+#include "cs_mut.h"
 
 /* allocate a vtable by allocating its Classifier and SDB.  Set up Classifier
  * according to the given classifier.  Set up the default action according to
@@ -34,7 +34,7 @@
 	fe_sdb_entry_t sdb_entry;
 	int ret;
 
-	new_table = kzalloc(sizeof(cs_vtable_t), GFP_ATOMIC);
+	new_table = cs_zalloc(sizeof(cs_vtable_t), GFP_ATOMIC);
 	if (new_table == NULL)
 		return NULL;
 
@@ -48,7 +48,7 @@
 	/* alloc classifier and sdb entry */
 	ret = cs_fe_table_alloc_entry(FE_TABLE_SDB, &new_table->sdb_index, 0);
 	if (ret != 0) {
-		kfree(new_table);
+		cs_free(new_table);
 		return NULL;
 	}
 
@@ -94,7 +94,7 @@
 EXIT_FREE_SDB:
 	cs_fe_table_del_entry_by_idx(FE_TABLE_SDB, new_table->sdb_index, false);
 
-	kfree(new_table);
+	cs_free(new_table);
 
 	return NULL;
 } /* cs_vtable_alloc */
diff -ruN a/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc.c b/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc.c
--- a/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc.c	2016-01-20 14:57:03.456510509 +0100
@@ -138,6 +138,7 @@
 #endif //CONFIG_CS75XX_HW_ACCEL_IPLIP
 //--BUG#40328
 
+#include "cs_mut.h"
 
 /*
  * Global Debug Flags
@@ -330,6 +331,8 @@
 #define RT3593_DMA_SYNC		"dma_sync"
 #define ACP_ENABLE		"acp_enable"
 #define CORE_CS_CB_DEBUG	"cs_cb_info"
+#define NE_MEMTRACE		"ne_memtrace"
+#define SKB_RECYCLE		"skb_recycle"
 #define IPC_LIST_STATUS		"ipc_list_status"
 //++ For WFO
 #define WFO_DEBUG		"wifi_offload_debug"
@@ -2792,6 +2795,11 @@
 	cs752x_add_proc_handler(NI_MIN_RSVE_MEM, cs_ni_min_rsve_mem_read_proc,
                                 cs_ni_min_rsve_mem_write_proc,
                                 proc_driver_cs752x_ne_ni);
+#ifdef CONFIG_CS75XX_MUT
+	cs752x_add_proc_handler(SKB_RECYCLE, mut_skb_recycle_proc_read,
+                                mut_skb_recycle_proc_write,
+                                proc_driver_cs752x_ne_ni);
+#endif
 	cs752x_add_proc_handler(QM_DEBUG, cs_qm_debug_read_proc,
 				cs_qm_debug_write_proc,
 				proc_driver_cs752x_ne_qm);
@@ -2833,6 +2841,13 @@
 					cs_ne_cs_cb_debug_write_proc,
 					proc_driver_cs752x_ne_core);
 
+#ifdef CONFIG_CS75XX_MUT
+	cs752x_add_proc_handler(NE_MEMTRACE,
+					mut_ne_memtrace_proc_read,
+					mut_ne_memtrace_proc_write,
+					proc_driver_cs752x_ne_core);
+#endif
+
 	cs752x_add_proc_handler(PCIE_DEBUG, cs_pcie_debug_read_proc,
 				cs_pcie_debug_write_proc,
 				proc_driver_cs752x_pcie);
diff -ruN a/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc_mcast.c b/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc_mcast.c
--- a/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc_mcast.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/diagnostic/cs752x_proc_mcast.c	2016-01-20 14:57:03.456510509 +0100
@@ -23,6 +23,8 @@
 
 #include <mach/cs_mcast.h>
 
+#include "cs_mut.h"
+
 #ifdef CONFIG_CS75XX_MTU_CHECK
 extern cs_port_id_t cs_wan_port_id;
 #endif
@@ -407,7 +409,7 @@
 		return count;
 	}
 
-	if ((entry_p = (cs_mcast_member_t *) kzalloc(sizeof(cs_mcast_member_t) * num, GFP_KERNEL)) == NULL) {
+	if ((entry_p = (cs_mcast_member_t *) cs_zalloc(sizeof(cs_mcast_member_t) * num, GFP_KERNEL)) == NULL) {
 		printk(KERN_INFO "%s: Can not alloc memory.\n", __func__);
 		return count;
 	}
@@ -434,13 +436,13 @@
 					entry_p++;
 				} /* for (i=0; i< num; i++) */
 				printk("=====================================\n");
-//				kfree(entry_org_p);
+//				cs_free(entry_org_p);
 			} /* if (entry_pp!= NULL) */
 		} /* if (num != 0) */
 	} /* if (cs_l2_mcast_port_member_get) */
 
 	if (entry_org_p != NULL)
-		kfree(entry_org_p);
+		cs_free(entry_org_p);
 
 	return count;
 
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l2_rslt_util.c b/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l2_rslt_util.c
--- a/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l2_rslt_util.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l2_rslt_util.c	2016-01-20 14:57:03.448510508 +0100
@@ -20,6 +20,7 @@
 #include <linux/list.h>
 #include "cs_fe.h"
 #include "crc.h"
+#include "cs_mut.h"
 
 typedef struct fe_l2_rslt_lookup_entry_s {
 	u16 crc16;
@@ -126,7 +127,7 @@
 
 	/* if reach here, we will need to create a new entry for this
 	 * allocation */
-	entry = kzalloc(sizeof(fe_l2_rslt_lookup_entry_t), GFP_ATOMIC);
+	entry = cs_zalloc(sizeof(fe_l2_rslt_lookup_entry_t), GFP_ATOMIC);
 	if (entry == NULL) {
 		status = FE_TABLE_ENOMEM;
 		goto exit;
@@ -134,7 +135,7 @@
 
 	status = cs_fe_table_add_l2_mac(mac_sa, mac_da, &l2_idx);
 	if (status != FE_TABLE_OK) {
-		kfree(entry);
+		cs_free(entry);
 		goto exit;
 	}
 
@@ -224,7 +225,7 @@
 				if (status == FE_TABLE_OK) {
 					list_del(&entry->list);
 					map_table[l2_idx] = 0;
-					kfree(entry);
+					cs_free(entry);
 				}
 			}
 			goto exit;
@@ -267,7 +268,7 @@
 //	int i;
 //	for (i=0; i<size; i++) {
 //		if(table_base[i])
-//			kfree(table_base[i]);
+//			cs_free(table_base[i]);
 //	}
 //	return FE_STATUS_OK;
 //}
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l3_rslt_util.c b/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l3_rslt_util.c
--- a/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l3_rslt_util.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/core/cs_fe_l3_rslt_util.c	2016-01-20 14:57:03.448510508 +0100
@@ -20,6 +20,7 @@
 #include <linux/list.h>
 #include "cs_fe.h"
 #include "crc.h"
+#include "cs_mut.h"
 
 typedef struct fe_l3_rslt_lookup_entry_s {
 	u16 crc16;
@@ -92,7 +93,7 @@
 
 	/* if reach here, we will need to create a new entry for this
 	 * allocation */
-	entry = kzalloc(sizeof(fe_l3_rslt_lookup_entry_t), GFP_ATOMIC);
+	entry = cs_zalloc(sizeof(fe_l3_rslt_lookup_entry_t), GFP_ATOMIC);
 	if (entry == NULL) {
 		status = FE_TABLE_ENOMEM;
 		goto exit;
@@ -100,7 +101,7 @@
 
 	status = cs_fe_table_add_l3_ip(ip_addr, &l3_idx, is_v6);
 	if (status != FE_TABLE_OK) {
-		kfree(entry);
+		cs_free(entry);
 		goto exit;
 	}
 
@@ -146,7 +147,7 @@
 				status = cs_fe_table_del_l3_ip(l3_idx, is_v6);
 				if (status == FE_TABLE_OK) {
 					list_del(&entry->list);
-					kfree(entry);
+					cs_free(entry);
 					fe_l3_rslt_lookup_and_entry_map_tbl[
 						l3_idx] = 0;
 				}
@@ -205,7 +206,7 @@
 //	spin_lock(&L3_IP_LOCK);
 //	for (i=0; i<4096; i++) {
 //		if (fe_l3_rslt_lookup_table_base[i])
-//			kfree(fe_l3_rslt_lookup_table_base[i]);
+//			cs_free(fe_l3_rslt_lookup_table_base[i]);
 //	}
 //	spin_unlock(&L3_IP_LOCK);
 //	return FE_STATUS_OK;
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_hw_table.c b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_hw_table.c
--- a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_hw_table.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_hw_table.c	2016-01-20 14:57:03.452510509 +0100
@@ -22,6 +22,7 @@
 #include "cs_fe_head_table.h"
 #include "cs_fe_hw_table_api.h"
 #include "cs_fe.h"
+#include "cs_mut.h"
 
 #define GET_MASK(len) (0xFFFFFFFF >> (32-(len)))
 #define GET_LO_MASK(start_pos)	(0xFFFFFFFF << (start_pos))
@@ -355,7 +356,7 @@
 #ifdef CONFIG_TEST_READ_AFTER_WRITE
 	table_head = cs_fe_hw_table_info[table_type].table_head;
 	total_width = table_head[field].total_width;
-	value = kmalloc((total_width / 32) * 4 + 4, GFP_ATOMIC);
+	value = ca_malloc((total_width / 32) * 4 + 4, GFP_ATOMIC);
 	if (!value)
 		return status;
 
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_acl.c b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_acl.c
--- a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_acl.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_acl.c	2016-01-20 14:57:03.452510509 +0100
@@ -22,6 +22,7 @@
 #include "cs_fe_hw_table_api.h"
 #include "cs_fe_table_generic.h"
 #include "cs752x_ioctl.h"
+#include "cs_mut.h"
 
 static cs_fe_table_t cs_fe_acl_table_type;
 
@@ -1199,8 +1200,8 @@
 		f_clean_entry = true;
 
 	if (f_clean_entry == true) {
-		kfree(p_fe_entry->p_entry);
-		kfree(p_sw_entry->data);
+		cs_free(p_fe_entry->p_entry);
+		cs_free(p_sw_entry->data);
 		cs_fe_acl_table_type.used_entry--;
 		ret = cs_fe_hw_table_clear_entry(FE_TABLE_ACL_RULE, idx);
 		if (ret != 0) {
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_generic.c b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_generic.c
--- a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_generic.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_generic.c	2016-01-20 14:57:03.448510508 +0100
@@ -21,6 +21,7 @@
 #include "cs_fe_table_int.h"
 #include "cs_fe_hw_table_api.h"
 #include "cs_fe_table_generic.h"
+#include "cs_mut.h"
 
 int fe_table_inc_entry_refcnt(cs_fe_table_t *table_type_ptr, unsigned int idx)
 {
@@ -122,15 +123,15 @@
 
 void *fe_table_malloc_table_entry(cs_fe_table_t *table_type_ptr)
 {
-	fe_table_entry_t *p_rslt = (fe_table_entry_t*)kzalloc(
-			sizeof(fe_table_entry_t), GFP_ATOMIC);
+	fe_table_entry_t *p_rslt = (fe_table_entry_t*) cs_zalloc(
+			sizeof(fe_table_entry_t), GFP_ATOMIC);
 
 	if (p_rslt == NULL)
 		return NULL;
 	atomic_set(&p_rslt->users, 0);
-	p_rslt->p_entry = kzalloc(table_type_ptr->entry_size, GFP_ATOMIC);
+	p_rslt->p_entry = cs_zalloc(table_type_ptr->entry_size, GFP_ATOMIC);
 	if (p_rslt->p_entry == NULL) {
-		kfree(p_rslt);
+		cs_free(p_rslt);
 		return NULL;
 	}
 
@@ -367,9 +368,9 @@
 		f_clean_entry = true;
 
 	if (f_clean_entry == true) {
-		kfree(p_fe_entry->p_entry);
+		cs_free(p_fe_entry->p_entry);
 		p_fe_entry->p_entry = NULL;
-		kfree(p_sw_entry->data);
+		cs_free(p_sw_entry->data);
 		p_sw_entry->data = NULL;
 		table_type_ptr->used_entry--;
 		p_sw_entry->local_data &= ~FE_TABLE_ENTRY_USED;
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l2mac.c b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l2mac.c
--- a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l2mac.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l2mac.c	2016-01-20 14:57:03.452510509 +0100
@@ -26,6 +26,7 @@
 #include "cs_fe_hw_table_api.h"
 #include "cs_fe_table_generic.h"
 #include "cs752x_ioctl.h"
+#include "cs_mut.h"
 
 static cs_fe_table_t cs_fe_l2mac_table_type;
 
@@ -328,8 +329,8 @@
 
 	if ((p_l2_entry->sa_count == 0) && (p_l2_entry->da_count == 0)) {
 		atomic_set(&p_fe_entry->users, 0);
-		kfree(p_fe_entry->p_entry);
-		kfree(p_sw_entry->data);
+		cs_free(p_fe_entry->p_entry);
+		cs_free(p_sw_entry->data);
 		p_sw_entry->data = NULL;
 		cs_fe_l2mac_table_type.used_entry--;
 		p_sw_entry->local_data &= ~FE_TABLE_ENTRY_USED;
diff -ruN a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l3ip.c b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l3ip.c
--- a/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l3ip.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/fe/table/cs_fe_table_l3ip.c	2016-01-20 14:57:03.452510509 +0100
@@ -32,6 +32,7 @@
 #include "cs_fe_table_generic.h"
 #include "cs752x_ioctl.h"
 #include "cs_fe_util_api.h"
+#include "cs_mut.h"
 
 static cs_fe_table_t cs_fe_l3ip_table_type;
 
@@ -318,9 +319,9 @@
 		}
 		atomic_dec(&p_fe_entry->users);
 		if (atomic_read(&p_fe_entry->users) == 0) {
-			kfree(p_fe_entry->p_entry);
+			cs_free(p_fe_entry->p_entry);
 			p_fe_entry->p_entry = NULL;
-			kfree(p_sw_entry->data);
+			cs_free(p_sw_entry->data);
 			p_sw_entry->data = NULL;
 			cs_fe_l3ip_table_type.used_entry--;
 			p_sw_entry->local_data &= ~FE_TABLE_ENTRY_USED;
diff -ruN a/drivers/net/ethernet/cs752x/src/include/cs_mut.h b/drivers/net/ethernet/cs752x/src/include/cs_mut.h
--- a/drivers/net/ethernet/cs752x/src/include/cs_mut.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/net/ethernet/cs752x/src/include/cs_mut.h	2016-01-20 14:57:03.456510509 +0100
@@ -0,0 +1,20 @@
+#ifndef __CS_MUT_H__
+#define __CS_MUT_H__
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/rbtree.h>
+
+/***** kmalloc family *****/
+
+void *cs_malloc(size_t size, gfp_t flags);
+void cs_free(void *ptr);
+
+#define cs_zalloc(size, flags) cs_malloc(size, (flags)|__GFP_ZERO)
+
+/***** initialization *****/
+
+int cs_kmem_cache_create(void);
+
+#endif /* __CS_MUT_H__ */
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/arp/cs_hw_arp.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/arp/cs_hw_arp.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/arp/cs_hw_arp.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/arp/cs_hw_arp.c	2016-01-20 14:57:03.452510509 +0100
@@ -7,6 +7,7 @@
 #include <mach/cs_network_types.h>
 #include "cs_hw_accel_arp.h"
 #include "cs_core_hmu.h"
+#include "cs_mut.h"
 
 #define PFX     "CS_HW_ARP"
 #define PRINT(format, args...) printk(KERN_WARNING PFX \
@@ -23,7 +24,7 @@
 {
 	cs_core_hmu_value_t *new_core_value;
 
-	new_core_value = kzalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
+	new_core_value = cs_zalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
 	if (new_core_value == NULL)
 		return NULL;
 
@@ -38,7 +39,7 @@
 {
 	cs_core_hmu_value_t *new_core_value;
 
-	new_core_value = kzalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
+	new_core_value = cs_zalloc(sizeof(cs_core_hmu_value_t), GFP_ATOMIC);
 	if (new_core_value == NULL)
 		return NULL;
 
@@ -86,7 +87,7 @@
 		*last_use = curr_last_use;
 	}
 
-	kfree(core_value);
+	cs_free(core_value);
 	return ret;
 }
 
@@ -126,7 +127,7 @@
 		cs_core_hmu_delete_hash(CS_CORE_HMU_WATCH_IN_IPV4_SA, core_value);
 	}
 		
-	kfree(core_value);
+	cs_free(core_value);
 
 	return;
 } /* cs_neigh_delete */
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/common/cs_hw_accel_sa_id.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/common/cs_hw_accel_sa_id.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/common/cs_hw_accel_sa_id.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/common/cs_hw_accel_sa_id.c	2016-01-20 14:57:03.452510509 +0100
@@ -27,6 +27,7 @@
 
 #include "cs_hw_accel_sa_id.h"
 #include <mach/cs_vpn_tunnel_ipc.h>
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -218,7 +219,7 @@
 	
 	*sa_id = index;
 
-	p_sa_id = kzalloc(sizeof(cs_sa_id_t), GFP_KERNEL);
+	p_sa_id = cs_zalloc(sizeof(cs_sa_id_t), GFP_KERNEL);
 	if (p_sa_id == NULL) {
 		ERR(printk("%s:%d out of memory\n",
 			__func__, __LINE__));
@@ -260,7 +261,7 @@
 		default:
 			break;
 		}
-		kfree(cs_sa_id_tbl[direction][sa_id]);
+		cs_free(cs_sa_id_tbl[direction][sa_id]);
 		cs_sa_id_tbl[direction][sa_id] = NULL;
 		DBG(printk("%s:%d free sa_id=%d successfully\n", __func__, __LINE__, sa_id));
 		return CS_OK;
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_flow_hash.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_flow_hash.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_flow_hash.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_flow_hash.c	2016-01-20 14:57:03.452510509 +0100
@@ -30,6 +30,7 @@
 #include <mach/cs_rule_hash_api.h>
 #include <mach/cs_flow_api.h>
 #include "cs_fe.h"
+#include "cs_mut.h"
 
 #include <cs752x_proc.h>
 extern u32 cs_adapt_debug;
@@ -526,7 +527,7 @@
 		return CS_ERROR;
 	}
 
-	p_flow_hash = kmalloc(sizeof(cs_flow_hash_internal_t), GFP_ATOMIC);
+	p_flow_hash = cs_malloc(sizeof(cs_flow_hash_internal_t), GFP_ATOMIC);
 	if (p_flow_hash == NULL) {
 		printk("%s: malloc sizeof(cs_flow_hash_internal_t) failed!!\n", __func__);
 		return CS_ERROR;
@@ -538,7 +539,7 @@
 	ret = cs_core_hmu_add_hash(p_rule_hash->hash_index, p_flow->life_time, p_flow_hash);
 	if (ret != CS_OK) {
 		printk("%s: cs_core_hmu_add_hash(hash_index=%d) failed!!\n", __func__, p_rule_hash->hash_index);
-		kfree(p_flow_hash);
+		cs_free(p_flow_hash);
 		return CS_ERROR;
 	}
 	cs_core_hmu_set_result_idx(p_rule_hash->hash_index, p_rule_hash->fwd_rslt_idx, 0);
@@ -766,7 +767,7 @@
 		p_rule_hash->key.mc_idx = tmp_mc_idx;
 
 		if (ret != CS_OK) {
-			//kfree(p_flow_hash);
+			//cs_free(p_flow_hash);
 			printk("%s: cs_rep_hash_add() failed!\n", __func__);
 			cs_flow_hash_delete(p_flow_hash->rule_hash.hash_index);
 			return ret;
@@ -932,7 +933,7 @@
 	p_flow_hash = (cs_flow_hash_internal_t *) data;
 	if (p_flow_hash != NULL) {
 		if (p_flow_hash->hash_type != CS_FLOW_HASH_TYPE) {
-			kfree(p_flow_hash);
+			cs_free(p_flow_hash);
 			//printk("%s: hash type is %d, not FLOW HASH!!\n", __func__, p_flow_hash->hash_type);
 			return CS_ERROR;
 		}
@@ -953,7 +954,7 @@
 				printk("%s: cs_rep_hash_del() failed!\n", __func__);
 			}
 		}
-		kfree(p_flow_hash);
+		cs_free(p_flow_hash);
 	}
 	return CS_OK;
 }
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_rule_hash.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_rule_hash.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_rule_hash.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/hash/cs_rule_hash.c	2016-01-20 14:57:03.452510509 +0100
@@ -36,6 +36,7 @@
 #include "cs_core_rule_hmu.h"
 #include "cs_core_hmu.h"
 #include <mach/cs_rule_hash_api.h>
+#include "cs_mut.h"
 
 #include <cs752x_proc.h>
 extern u32 cs_adapt_debug;
@@ -606,7 +607,7 @@
 		return CS_ERROR;
 	}
 
-	p_rule_hash_internal = kmalloc(sizeof(cs_rule_hash_internal_t), GFP_ATOMIC);
+	p_rule_hash_internal = cs_malloc(sizeof(cs_rule_hash_internal_t), GFP_ATOMIC);
         if (p_rule_hash_internal == NULL) {
                 printk("%s: malloc sizeof(cs_rule_hash_internal_t) failed!!\n", __func__);
                 return CS_ERROR;
@@ -618,7 +619,7 @@
 	ret = cs_core_rule_hmu_add_hash(p_rule_hash->hash_index, p_rule_hash_internal);
         if (ret != CS_OK) {
                 printk("%s: cs_core_rule_hmu_add_hash(hash_index=%d) failed!!\n", __func__, p_rule_hash->hash_index);
-		kfree(p_rule_hash_internal);
+		cs_free(p_rule_hash_internal);
                 return CS_ERROR;
         }
         cs_core_rule_hmu_set_result_idx(p_rule_hash->hash_index, p_rule_hash->fwd_rslt_idx, 0);
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/ipsec/cs_hw_accel_ipsec.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/ipsec/cs_hw_accel_ipsec.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/ipsec/cs_hw_accel_ipsec.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/ipsec/cs_hw_accel_ipsec.c	2016-01-20 14:57:03.452510509 +0100
@@ -43,7 +43,7 @@
 #include <linux/etherdevice.h>
 #include "cs_hw_accel_manager.h"
 #include "cs_accel_cb.h"
-
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_HW_ACCEL_ETHERIP
 #include "cs_hw_accel_etherip.h"
@@ -232,7 +232,7 @@
 		return -1;
 	DBG(printk("%s:%d table_id=%d, sa_id=%d\n", __func__, __LINE__, table_id, sa_id));
 
-	p_skb_queue = kmalloc(sizeof(cs_ipsec_skb_queue_t), GFP_ATOMIC);
+	p_skb_queue = cs_malloc(sizeof(cs_ipsec_skb_queue_t), GFP_ATOMIC);
 	if (NULL == p_skb_queue)
 		return -1;
 	if (cs_cb != NULL)
@@ -274,7 +274,7 @@
 		if (pkt_cnt >= CS_IPSEC_CB_QUEUE_MAX) {
 			/* we are queuing too many packets.. going to drop this one..
 			 * in case of infinite loop */
-			kfree(p_skb_queue);
+			cs_free(p_skb_queue);
 			kfree_skb(skb);
 		} else
 			p_curr_skb_queue->next = p_skb_queue;
@@ -313,13 +313,13 @@
 		p_skb_queue = ipsec_main_db.re0_skb_q[sa_id];
 		ipsec_main_db.re0_skb_q[sa_id] = p_skb_queue->next;
 		rslt_skb = p_skb_queue->skb;
-		kfree(p_skb_queue);
+		cs_free(p_skb_queue);
 	} else if (NULL != ipsec_main_db.re1_skb_q[sa_id]) {
 		/* if there are skb queued in the list of table#1+sa_id, dequeue it */
 		p_skb_queue = ipsec_main_db.re1_skb_q[sa_id];
 		ipsec_main_db.re1_skb_q[sa_id] = p_skb_queue->next;
 		rslt_skb = p_skb_queue->skb;
-		kfree(p_skb_queue);
+		cs_free(p_skb_queue);
 	}
 	spin_unlock_bh(re_lock);
 
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/ip_translate/cs_hw_accel_ip_translate.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/ip_translate/cs_hw_accel_ip_translate.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/ip_translate/cs_hw_accel_ip_translate.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/ip_translate/cs_hw_accel_ip_translate.c	2016-01-20 14:57:03.452510509 +0100
@@ -37,6 +37,8 @@
 # include <linux/export.h>
 #endif
 
+#include "cs_mut.h"
+
 #ifdef CS_IPC_ENABLED
 #include <mach/cs_vpn_tunnel_ipc.h>
 #endif
@@ -405,7 +407,7 @@
 		goto add_exit;
 	}
 
-	tunnel = kzalloc(sizeof(cs_ip_translate_tunnel_t), GFP_KERNEL);
+	tunnel = cs_zalloc(sizeof(cs_ip_translate_tunnel_t), GFP_KERNEL);
 	if (tunnel == NULL) {
 		ERR(printk("%s:%d out of memory\n",	__func__, __LINE__));
 		ret = CS_E_MEM_ALLOC;
@@ -432,7 +434,7 @@
 
 	if (ret != CS_E_OK) {
 		cs_ip_translate_entry[idx] = NULL;
-		kfree(tunnel);
+		cs_free(tunnel);
 	} else {
 		DBG(printk("%s:%d add entry at idx %d\n", __func__, __LINE__, idx));
 		*p_ip_translate_id = idx;
@@ -518,7 +520,7 @@
 		cs_flow_delete(tunnel->device_id, entry->over_size_entry_from_pe.flow_id);
 		tmp = entry;
 		entry = entry->next;
-		kfree(tmp);
+		cs_free(tmp);
 	}
 
 	/*Remove PE->WAN and WAN->PE hash*/
@@ -531,7 +533,7 @@
 #endif /* CS_IPC_ENABLED */
 
 	cs_ip_translate_entry[ip_translate_id] = NULL;
-	kfree(tunnel);
+	cs_free(tunnel);
 
 	__CS_IP_TS_UNLOCK();
 	return CS_E_OK;
@@ -641,7 +643,7 @@
 		goto add_exit;
 	}
 
-	entry = kzalloc(sizeof(cs_ip_translate_flow_t), GFP_KERNEL);
+	entry = cs_zalloc(sizeof(cs_ip_translate_flow_t), GFP_KERNEL);
 	if (entry == NULL) {
 		ERR(printk("%s:%d out of memory\n", __func__, __LINE__));
 		ret = CS_E_MEM_ALLOC;
@@ -656,7 +658,7 @@
 	ret = __cs_ip_translate_entry_add_hash(tunnel, entry);
 
 	if (ret != CS_E_OK) {
-		kfree(entry);
+		cs_free(entry);
 		goto add_exit;
 	}
 
@@ -730,7 +732,7 @@
 	if (entry->next) {
 			entry->next->prev = entry->prev;
 	}
-	kfree(entry);
+	cs_free(entry);
 add_exit:
 	__CS_IP_TS_UNLOCK();
 	return ret;
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_hw_accel_mc.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_hw_accel_mc.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_hw_accel_mc.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_hw_accel_mc.c	2016-01-20 14:57:03.452510509 +0100
@@ -31,6 +31,7 @@
 
 #include "cs_wfo_csme.h"
 
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -197,7 +198,7 @@
 				(memcmp(entry->ip_addr,
 						ip_addr_tmp, len) == 0)) {
 				list_del_init(&entry->list);
-				kfree(entry);
+				cs_free(entry);
 				spin_unlock(&cs_mc_groupip_lookup_table_lock);
 				return;
 			}
@@ -265,7 +266,7 @@
 			return true;
 		} else {
 			/*if not find entry, create a new one*/
-			entry = kzalloc(sizeof(cs_mc_groupip_lookup_table_t), GFP_ATOMIC);
+			entry = cs_zalloc(sizeof(cs_mc_groupip_lookup_table_t), GFP_ATOMIC);
 			if (entry == NULL) {
 				spin_unlock(&cs_mc_groupip_lookup_table_lock);
 				return false;
@@ -328,7 +329,7 @@
 				entry = list_entry(pos, cs_mc_groupip_lookup_table_t, list);
 				if (entry->is_v6 == is_v6) {
 					list_del_init(&entry->list);
-					kfree(entry);
+					cs_free(entry);
 				}
 			}
 		}
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_mcast.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_mcast.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_mcast.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/multicast/cs_mcast.c	2016-01-20 14:57:03.452510509 +0100
@@ -34,7 +34,7 @@
 #include "cs_core_vtable.h"
 #include "cs_fe_hash.h"
 #include <mach/cs_mcast.h>
-
+#include "cs_mut.h"
 
 #define PROTO_IGMP	0x02
 #define PROTO_ICMPV6	0x3A
@@ -252,7 +252,7 @@
 	spin_lock_irqsave(&list_lock, flags);
 	while (tmp != NULL) {
 		next = tmp->next_src;
-		kfree(tmp);
+		cs_free(tmp);
 		tmp = next;
 	}
 	spin_unlock_irqrestore(&list_lock, flags);
@@ -315,7 +315,7 @@
 	if ((node = mcast_search_group(grp_addr)) != NULL)
 		return node;
 
-	if ((node = kzalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL)
+	if ((node = cs_zalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL)
 		return NULL;
 
 	if (grp_addr->afi == CS_IPV4)
@@ -460,7 +460,7 @@
 
 	spin_unlock_irqrestore(&list_lock, flags);
 
-	kfree(tmp);
+	cs_free(tmp);
 }
 
 static void mcast_dump_list(void)
@@ -817,7 +817,7 @@
 			DBG(printk(KERN_INFO "%s: can not find src node for addr %pI6\n", __func__, &src_addr->ip_addr.ipv4_addr));
 		}
 
-		if ((src_node = kzalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL) {
+		if ((src_node = cs_zalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL) {
 			printk(KERN_INFO "%s: Can not alloc memory.\n", __func__);
 			return NULL;
 		}
@@ -839,7 +839,7 @@
 
 		if (mcast_add_src(&group_node->addr, src_node) == NULL) {
 			printk(KERN_INFO "%s: mcast_add_src fail\n", __func__);
-			kfree(src_node);
+			cs_free(src_node);
 			return NULL;
 		}
 	}
@@ -1061,12 +1061,12 @@
 
 			src_tmp = src_node;
 			src_node = src_node->next_src;
-			kfree(src_tmp);
+			cs_free(src_tmp);
 		}
 
 		group_tmp = group_node;
 		group_node = group_node->next_group;
-		kfree(group_tmp);
+		cs_free(group_tmp);
 	}
 
 	head->next_group = NULL;
@@ -1219,7 +1219,7 @@
 
 	spin_lock_init(&list_lock);
 
-	if ((head = kzalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL) {
+	if ((head = cs_zalloc(sizeof(struct cs_mcast_node), GFP_KERNEL)) == NULL) {
 		printk(KERN_INFO "%s: Can not alloc memory.\n", __func__);
 		return CS_E_INIT;
 	}
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/netfilter/cs_hw_nf_drop.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/netfilter/cs_hw_nf_drop.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/netfilter/cs_hw_nf_drop.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/netfilter/cs_hw_nf_drop.c	2016-01-20 14:57:03.452510509 +0100
@@ -10,7 +10,7 @@
 #include "cs_hw_accel_manager.h"
 #include "cs_core_vtable.h"
 #include "cs_core_hmu.h"
-
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -183,7 +183,7 @@
 				 * to clean the list node first */
 				list_del_init(&nf_drop_check->node);
 				spin_unlock_bh(&nf_drop_lock);
-				kfree(nf_drop_check);
+				cs_free(nf_drop_check);
 				return true;
 			}
 		}
@@ -192,7 +192,7 @@
 	/* nothing has been found, so we are creating a node and insert
 	 * it to the list */
 	nf_drop_check = (cs_hw_nf_drop_check_t *)
-		kzalloc(sizeof(cs_hw_nf_drop_check_t), GFP_ATOMIC);
+		cs_zalloc(sizeof(cs_hw_nf_drop_check_t), GFP_ATOMIC);
 	if (!nf_drop_check) {
 		spin_unlock_bh(&nf_drop_lock);
 		return false;
@@ -241,7 +241,7 @@
 						nf_drop_check->last_use +
 						life_in_jiffies))) {
 			list_del_init(&nf_drop_check->node);
-			kfree(nf_drop_check);
+			cs_free(nf_drop_check);
 		}
 	}
 	spin_unlock_bh(&nf_drop_lock);
@@ -268,7 +268,7 @@
 	spin_lock_bh(&nf_drop_lock);
 	list_for_each_entry_safe(nf_drop_check, n, &nf_drop_check_tbl, node) {
 		list_del_init(&nf_drop_check->node);
-		kfree(nf_drop_check);
+		cs_free(nf_drop_check);
 	}
 	spin_unlock_bh(&nf_drop_lock);
 	printk("\ndone cleaning NF_DROP check table!\n");
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/qos/cs_hw_accel_qos_ingress.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/qos/cs_hw_accel_qos_ingress.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/qos/cs_hw_accel_qos_ingress.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/qos/cs_hw_accel_qos_ingress.c	2016-01-20 14:57:03.452510509 +0100
@@ -32,6 +32,7 @@
 #include "cs_core_vtable.h"
 #include "cs_core_hmu.h"
 #include "cs75xx_tm.h"
+#include "cs_mut.h"
 
 static int ingress_mode = CS_QOS_INGRESS_MODE_MAX;
 static unsigned char mode_name[CS_QOS_INGRESS_MODE_MAX + 1][8] = {
@@ -122,13 +123,13 @@
 		if (ingress_hash_table != NULL) {
 			for (i = 0; i < table_max; i++)
 				cs_qos_delete_qos_hash(ingress_hash_table[i]);
-			kfree(ingress_hash_table);
+			cs_free(ingress_hash_table);
 			ingress_hash_table = NULL;
 			table_max = 0;
 		}
 
 		if (queue_mapping_table != NULL) {
-			kfree(queue_mapping_table);
+			cs_free(queue_mapping_table);
 			queue_mapping_table = NULL;
 		}
 
@@ -279,8 +280,8 @@
 	ingress_qos_hm_idx = bc_vtable_hm_idx;
 
 	/* create all the hashes */
-	ingress_hash_table = kzalloc(table_max * 2, GFP_KERNEL);
-	queue_mapping_table = kmalloc(table_max, GFP_KERNEL);
+	ingress_hash_table = cs_zalloc(table_max * 2, GFP_KERNEL);
+	queue_mapping_table = cs_malloc(table_max, GFP_KERNEL);
 	if ((ingress_hash_table == NULL) || (queue_mapping_table == NULL))
 		return -1;
 
@@ -333,8 +334,8 @@
 				ingress_qos_hm_idx, true);
 #endif
 		ingress_qos_hm_idx = ~0x0;
-		kfree(ingress_hash_table);
-		kfree(queue_mapping_table);
+		cs_free(ingress_hash_table);
+		cs_free(queue_mapping_table);
 		return -1;
 	}
 
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/rtp/cs_hw_accel_rtp_proxy.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/rtp/cs_hw_accel_rtp_proxy.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/rtp/cs_hw_accel_rtp_proxy.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/rtp/cs_hw_accel_rtp_proxy.c	2016-01-20 14:57:03.452510509 +0100
@@ -45,6 +45,8 @@
 extern u32 cs_adapt_debug;
 #endif /* CONFIG_CS752X_PROC */
 
+#include "cs_mut.h"
+
 /* TODO:  add a RTP proxy cs_adapt_debug flag*/
 #define DBG(x)	if (cs_adapt_debug & CS752X_ADAPT_TUNNEL) (x)
 #define ERR(x)	(x)
@@ -128,7 +130,7 @@
 		return CS_E_CONFLICT;
 	}
 
-	p_rtp_node = kzalloc(sizeof(cs_rtp_entry_t), GFP_KERNEL);
+	p_rtp_node = cs_zalloc(sizeof(cs_rtp_entry_t), GFP_KERNEL);
 
 	if (p_rtp_node == NULL) {
 		ERR(printk("%s:%d out of memory\n",
@@ -155,7 +157,7 @@
 	else{
 		printk("%s:%d invalid ingress_pkt phy_port = %d\n", __func__, __LINE__,
 			p_flow_entry->ingress_pkt.phy_port);
-		kfree(p_rtp_node);
+		cs_free(p_rtp_node);
 		return CS_E_PARAM;
 	}
 
@@ -169,7 +171,7 @@
 	if (ret != CS_OK) {
 		ERR(printk("%s:%d can't apply sa_id\n",
 					__func__, __LINE__));
-		kfree(p_rtp_node);
+		cs_free(p_rtp_node);
 		return CS_E_CONFLICT;
 	}
 
@@ -178,7 +180,7 @@
 	if (ret != CS_OK) {
 		ERR(printk("%s:%d construct flow entries failed\n",
 					__func__, __LINE__));
-		kfree(p_rtp_node);
+		cs_free(p_rtp_node);
 		return ret;
 	}
 
@@ -257,7 +259,7 @@
 #ifdef CS_IPC_ENABLED
 			cs_rtp_ipc_send_del_entry(t->dir, t->sa_id);
 #endif /* CS_IPC_ENABLED */
-			kfree(t);
+			cs_free(t);
 			return CS_E_NONE;
 		}
 
@@ -309,7 +311,7 @@
 #ifdef CS_IPC_ENABLED
 			cs_rtp_ipc_send_del_entry(t->dir, t->sa_id);
 #endif /* CS_IPC_ENABLED */
-			kfree(t);
+			cs_free(t);
 			return CS_E_NONE;
 		}
 
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_iplip.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_iplip.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_iplip.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_iplip.c	2016-01-20 14:57:03.452510509 +0100
@@ -48,6 +48,7 @@
 #include <mach/cs_network_types.h>
 #include "cs_fe.h"
 #include "cs_hw_accel_tunnel.h"
+#include "cs_mut.h"
 
 #ifdef CS_IPC_ENABLED
 #include <mach/g2cpu_ipc.h>
@@ -1260,7 +1261,7 @@
 		p = p->next;
 	}
 
-	port_node = kzalloc(sizeof(cs_pppoe_port_entry_t), GFP_KERNEL);
+	port_node = cs_zalloc(sizeof(cs_pppoe_port_entry_t), GFP_KERNEL);
 	if (port_node == NULL) {
 		ERR(printk("%s:%d out of memory\n", __func__, __LINE__));
 		return CS_ERROR;
@@ -1314,7 +1315,7 @@
 				p2->next = p->next;
 			}
 			
-			kfree(p);
+			cs_free(p);
 			cs_pppoe_cb.pppoe_port_cnt--;
 			return CS_OK;
 		}
@@ -1430,8 +1431,8 @@
 				return CS_ERROR;
 			}
 			
-			tunnel_node = kzalloc(sizeof(cs_tunnel_entry_t),
-						GFP_KERNEL);
+			tunnel_node = cs_zalloc(sizeof(cs_tunnel_entry_t),
+						GFP_KERNEL);
 			if (tunnel_node == NULL) {
 				ERR(printk("%s:%d out of memory\n",
 					__func__, __LINE__));
@@ -1451,7 +1452,7 @@
 				/* no free tunnel_id */
 				ERR(printk("%s:%d no available tunnel\n",
 					__func__, __LINE__));
-				kfree(tunnel_node);
+				cs_free(tunnel_node);
 				return CS_ERROR;
 			}
 
@@ -1575,7 +1576,7 @@
 					if (t->fwd_hash_idx[2])
 						cs_iplip_pe2cpu_tunnel_hash_del(t);
 					
-					kfree(t);
+					cs_free(t);
 					return CS_OK;
 				}
 				t = t->next;
@@ -1641,7 +1642,7 @@
 	if (t->fwd_hash_idx[2])
 		cs_iplip_pe2cpu_tunnel_hash_del(t);
 
-	kfree(t);
+	cs_free(t);
 	return CS_OK;
 }
 
@@ -1708,7 +1709,7 @@
 		s = s->next;
 	}
 
-	session_node = kzalloc(sizeof(cs_l2tp_session_entry_t), GFP_KERNEL);
+	session_node = cs_zalloc(sizeof(cs_l2tp_session_entry_t), GFP_KERNEL);
 	if (session_node == NULL) {
 		ERR(printk("%s:%d out of memory\n",
 			__func__, __LINE__));
@@ -1787,7 +1788,7 @@
 				return CS_ERROR;
 			}
 
-			kfree(s);
+			cs_free(s);
 			return CS_OK;
 		}
 		
@@ -1893,7 +1894,7 @@
 				n = n->next;
 			}
 			
-			ip_node = kzalloc(sizeof(cs_ip_address_entry_t), GFP_KERNEL);
+			ip_node = cs_zalloc(sizeof(cs_ip_address_entry_t), GFP_KERNEL);
 			if (ip_node == NULL) {
 				ERR(printk("%s:%d out of memory\n",
 					__func__, __LINE__));
@@ -1995,7 +1996,7 @@
 					}
 
 					
-					kfree(n);
+					cs_free(n);
 					return CS_OK;
 				}
 				n = n->next;
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_ipsec_api.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_ipsec_api.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_ipsec_api.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_ipsec_api.c	2016-01-20 14:57:03.456510509 +0100
@@ -46,6 +46,7 @@
 #include "cs_fe.h"
 #include "cs_hw_accel_tunnel.h"
 #include "cs_hw_accel_sa_id.h"
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -1097,7 +1098,7 @@
 	}
 	idx = spd_handle;
 	
-	p_node = kzalloc(sizeof(cs_ipsec_policy_node_t), GFP_KERNEL);
+	p_node = cs_zalloc(sizeof(cs_ipsec_policy_node_t), GFP_KERNEL);
 	if (p_node == NULL) {
 		ERR(printk("%s:%d out of memory\n", __func__, __LINE__));
 		return CS_E_RESOURCE;
@@ -1122,7 +1123,7 @@
 		spin_unlock_irqrestore(&cs_ipsec_lock, flags);
 		ERR(printk("%s:%d index = %d, spd is invalid.\n",
 			__func__, __LINE__, idx));
-		kfree(p_node);
+		cs_free(p_node);
 		return CS_E_NOT_FOUND;
 	}
 	
@@ -1207,7 +1208,7 @@
 			}
 			cs_ipsec_spd[idx].policy_cnt--;
 			spin_unlock_irqrestore(&cs_ipsec_lock, flags);
-			kfree(p);
+			cs_free(p);
 			return CS_E_NONE;
 		}
 		pre_p = p;
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_l2tp_ipsec.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_l2tp_ipsec.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_l2tp_ipsec.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/tunnel/cs_hw_accel_l2tp_ipsec.c	2016-01-20 14:57:03.456510509 +0100
@@ -46,6 +46,7 @@
 #include "cs_fe.h"
 #include "cs_hw_accel_tunnel.h"
 #include "cs_hw_accel_sa_id.h"
+#include "cs_mut.h"
 #ifdef CONFIG_CS75XX_HW_ACCEL_IP_TRANSLATE
 #include "cs_hw_accel_ip_translate.h"
 #endif
@@ -670,7 +671,7 @@
 		" p_tunnel_id = 0x%p\n",
 		__func__, __LINE__, device_id, p_tunnel_cfg, p_tunnel_id));
 
-	tunnel_node = kzalloc(sizeof(cs_tunnel_entry_t), GFP_KERNEL);
+	tunnel_node = cs_zalloc(sizeof(cs_tunnel_entry_t), GFP_KERNEL);
 	if (tunnel_node == NULL) {
 		ERR(printk("%s:%d out of memory\n",
 			__func__, __LINE__));
@@ -723,7 +724,7 @@
 		ERR(printk("%s:%d unknown direction %d\n",
 					__func__, __LINE__,
 					tunnel_node->tunnel_cfg.dir));
-		kfree(tunnel_node);
+		cs_free(tunnel_node);
 		return CS_E_CONFLICT;
 	}
 
@@ -742,7 +743,7 @@
 		if (ret != CS_OK) {
 			ERR(printk("%s:%d can't apply sa_id\n",
 						__func__, __LINE__));
-			kfree(tunnel_node);
+			cs_free(tunnel_node);
 			return CS_E_CONFLICT;
 		}
 		break;
@@ -759,7 +760,7 @@
 		ERR(printk("%s:%d unknown tunnel type %d\n",
 					__func__, __LINE__,
 					tunnel_node->tunnel_cfg.type));
-		kfree(tunnel_node);
+		cs_free(tunnel_node);
 		return CS_E_CONFLICT;
 	}
 
@@ -775,7 +776,7 @@
 				ERR(printk("%s:%d can't get IPSec "
 						"policy node\n",
 						__func__, __LINE__));
-				kfree(tunnel_node);
+				cs_free(tunnel_node);
 				return CS_E_CONFLICT;
 			}
 
@@ -786,7 +787,7 @@
 					"(%d) or invalid sa (%d)\n",
 					__func__, __LINE__,
 					p_node.valid, p_node.sa_valid));
-				kfree(tunnel_node);
+				cs_free(tunnel_node);
 				return CS_E_CONFLICT;
 			}
 
@@ -803,7 +804,7 @@
 						" IPSec selectors are "
 						"mismatched\n",
 						__func__, __LINE__));
-					kfree(tunnel_node);
+					cs_free(tunnel_node);
 					return CS_E_CONFLICT;
 				}
 			}
@@ -822,7 +823,7 @@
 				ERR(printk("%s:%d can't update tunnel_"
 						"id to IPSec policy\n",
 						__func__, __LINE__));
-				kfree(tunnel_node);
+				cs_free(tunnel_node);
 				return CS_E_CONFLICT;
 			}
 
@@ -831,7 +832,7 @@
 			/* invalid policy_handle */
 			ERR(printk("%s:%d invalid IPSec policy_handle\n",
 						__func__, __LINE__));
-			kfree(tunnel_node);
+			cs_free(tunnel_node);
 			return CS_E_CONFLICT;
 		}
 	}
@@ -876,7 +877,7 @@
 			cs_tunnel_cb.tu_cnt--;
 			spin_unlock_irqrestore(&cs_l2tp_lock, flags);
 
-			kfree(tunnel_node);
+			cs_free(tunnel_node);
 			return CS_E_CONFLICT;
 		}
 
@@ -942,7 +943,7 @@
 				cs_l2tp_del_ipc_send(t);
 			}
 
-			kfree(t);
+			cs_free(t);
 			return CS_E_NONE;
 		}
 
@@ -1015,7 +1016,7 @@
 #ifdef CS_IPC_ENABLED
 			cs_ipsec_ipc_send_del_entry(dir, t->sa_id);
 #endif /* CS_IPC_ENABLED */
-			kfree(t);
+			cs_free(t);
 			return CS_E_NONE;
 		}
 
@@ -1091,7 +1092,7 @@
 				cs_l2tp_del_ipc_send(t);
 			}
 
-			kfree(t);
+			cs_free(t);
 			return CS_E_NONE;
 		}
 
@@ -1141,7 +1142,7 @@
 	DBG(printk("%s:%d device_id=%d, tunnel_id = %d, session_id = 0x%x\n",
 		__func__, __LINE__, device_id, tunnel_id, session_id));
 
-	session_node = kzalloc(sizeof(cs_l2tp_session_entry_t), GFP_KERNEL);
+	session_node = cs_zalloc(sizeof(cs_l2tp_session_entry_t), GFP_KERNEL);
 	if (session_node == NULL) {
 		ERR(printk("%s:%d out of memory\n", __func__, __LINE__));
 		return CS_E_MEM_ALLOC;
@@ -1167,7 +1168,7 @@
 						ERR(printk("%s:%d duplicate "
 							"session ID\n",
 							__func__, __LINE__));
-						kfree(session_node);
+						cs_free(session_node);
 						return CS_E_CONFLICT;
 					}
 					s2 = s;
@@ -1182,7 +1183,7 @@
 						&cs_l2tp_lock, flags);
 					printk("##L2TP## only support "
 						"one session per tunnel\n");
-					kfree(session_node);
+					cs_free(session_node);
 					return CS_E_CONFLICT;
 				}
 				session_node->tunnel = t;
@@ -1196,7 +1197,7 @@
 				ERR(printk("%s:%d invalid tunnel type (%d)\n",
 					__func__, __LINE__,
 					t->tunnel_cfg.type));
-				kfree(session_node);
+				cs_free(session_node);
 				return CS_E_CONFLICT;
 			}
 
@@ -1250,7 +1251,7 @@
 						/* send IPCs and delete hash */
 						cs_l2tp_del_ipc_send(t);
 
-						kfree(s);
+						cs_free(s);
 						return CS_E_NONE;
 					}
 					s = s->next;
diff -ruN a/drivers/net/ethernet/cs752x/src/kernel_adapt/wfo/cs_wfo_csme.c b/drivers/net/ethernet/cs752x/src/kernel_adapt/wfo/cs_wfo_csme.c
--- a/drivers/net/ethernet/cs752x/src/kernel_adapt/wfo/cs_wfo_csme.c	2016-01-20 14:50:42.660496287 +0100
+++ b/drivers/net/ethernet/cs752x/src/kernel_adapt/wfo/cs_wfo_csme.c	2016-01-20 14:57:03.452510509 +0100
@@ -9,7 +9,7 @@
 
 #include <mach/cs_types.h>
 #include "cs_wfo_csme.h"
-
+#include "cs_mut.h"
 
 #ifdef CONFIG_CS752X_PROC
 #include "cs752x_proc.h"
@@ -202,7 +202,7 @@
     if (macdaNotFound) {
    	    // add pmember_addr into MAC DA for key list
     	pMACDA = (struct csme_mac_da_list*)
-    	            kmalloc(sizeof(struct csme_mac_da_list), GFP_ATOMIC);
+    	            cs_malloc(sizeof(struct csme_mac_da_list), GFP_ATOMIC);
 
     	if (!pMACDA) {
             DBG(printk("%s,%d:: ERROR allocate memory for pMACDA fail\n",
@@ -230,7 +230,7 @@
     
     // add pgrp_addr into csme_mac_da_grp_list list
 	pMACDAGrp = (struct csme_mac_da_grp_list*)
-	                kmalloc(sizeof(struct csme_mac_da_grp_list), GFP_ATOMIC);
+	                cs_malloc(sizeof(struct csme_mac_da_grp_list), GFP_ATOMIC);
 
 	if (!pMACDAGrp) {
         DBG(printk("%s,%d:: ERROR allocate memory for pMACDAGrp fail\n",
@@ -281,7 +281,7 @@
     if (grpNotFound) {
    	    // add pgrp_addr into Group for key list
     	pGrp = (struct csme_grp_list*)
-    	            kmalloc(sizeof(struct csme_grp_list), GFP_ATOMIC);
+    	            cs_malloc(sizeof(struct csme_grp_list), GFP_ATOMIC);
 
     	if (!pGrp) {
             DBG(printk("%s,%d:: ERROR allocate memory for pGrp fail\n",
@@ -297,7 +297,7 @@
     
     // add pmember_addr into csme_grp_member_list list
 	pGrpMember = (struct csme_grp_member_list*)
-	                kmalloc(sizeof(struct csme_grp_member_list), GFP_ATOMIC);
+	                cs_malloc(sizeof(struct csme_grp_member_list), GFP_ATOMIC);
 
 	if (!pGrpMember) {
         DBG(printk("%s,%d:: ERROR allocate memory for pGrpMember fail\n",
@@ -609,7 +609,7 @@
                                     ETH_ALEN ) == 0) {
                             // delete node from grp_member_list list and free resource
                             list_del(&(pGrpMember->grp_member_list));
-                            kfree(pGrpMember);
+                            cs_free(pGrpMember);
 
             	            // delete hash
             	            __cs_mc_delete_hash_by_ipv4_group(0, pGrp->group_ip);
@@ -626,7 +626,7 @@
                 if (list_empty(&(pGrp->grp_member_head))) {
                     // delete list and free resource
                     list_del(&(pGrp->grp_list));
-                    kfree(pGrp);
+                    cs_free(pGrp);
                     break;
                 }
             }/* if (memcmp( pGrp->group_addr, pgrp_addr, ETH_ALEN) == 0) */
@@ -660,7 +660,7 @@
                                     ETH_ALEN ) == 0) {
                             // delete list and free resource
                             list_del(&(pMACDAGrp->mac_da_grp_list));
-                            kfree(pMACDAGrp);
+                            cs_free(pMACDAGrp);
                             retStatus = CS_WFO_CSME_STATUS_SUCCESS;
                             break;
                         }/* if (memcmp) */
@@ -685,7 +685,7 @@
 
                     // delete list and free resource
                     list_del(&(pMACDA->mac_da_list));
-                    kfree(pMACDA);
+                    cs_free(pMACDA);
                 }
             }/* if (memcmp(pMACDA->mac_da, pmember_addr, ETH_ALEN) == 0) */
         }/* list_for_each_safe(nextMACDATmp, nextMACDAGrpTmp, &grp_member_head) */
@@ -769,11 +769,11 @@
 
                                                 // delete list and free resource
                                                 list_del(&(pGrpMember->grp_member_list));
-                                                kfree(pGrpMember);
+                                                cs_free(pGrpMember);
 
                                                 // delete list and free resource
                                                 list_del(&(pMACDAGrp->mac_da_grp_list));
-                                                kfree(pMACDAGrp);
+                                                cs_free(pMACDAGrp);
 
                                                 retStatus = CS_WFO_CSME_STATUS_SUCCESS;
                                                 break;
@@ -799,7 +799,7 @@
 
                                         // delete list and free resource
                                         list_del(&(pGrp->grp_list));
-                                        kfree(pGrp);
+                                        cs_free(pGrp);
                                     }
                                 }/*if (memcmp()) */
                             }/* list_for_each_safe */
@@ -810,7 +810,7 @@
                 if (list_empty(&(pMACDA->mac_da_grp_head))) {
                     // delete list and free resource
                     list_del(&(pMACDA->mac_da_list));
-                    kfree(pMACDA);
+                    cs_free(pMACDA);
                 }
             }/* if (memcmp(pMACDA->mac_da, pMACDA->mac_da, ETH_ALEN) == 0) */
         }/* list_for_each_safe(nextMACDA, nextMACDATmp, &mac_da_head) */
@@ -863,7 +863,7 @@
                                            grp_member_list);
                     // delete list and free resource
                     list_del(&(pGrpMember->grp_member_list));
-                    kfree(pGrpMember);
+                    cs_free(pGrpMember);
                 }/* list_for_each_safe(nextGrpMember) */
             }/* if (!list_empty(&(pGrp->grp_list)) */
             
@@ -873,7 +873,7 @@
 
             // delete list and free resource
             list_del(&(pGrp->grp_list));
-            kfree(pGrp);
+            cs_free(pGrp);
         }/* list_for_each_safe(nextGrp, nextGrpTmp, &grp_head) */
     }/* if (!list_empty(&mac_da_head)) */
     
@@ -898,13 +898,13 @@
 
                     // delete list and free resource
                     list_del(&(pMACDAGrp->mac_da_grp_list));
-                    kfree(pMACDAGrp);
+                    cs_free(pMACDAGrp);
                 }/* list_for_each_safe(nextMACDAGrp, nextMACDAGrpTmp, &(pMACDA->mac_da_list)) */
             }/* if (!list_empty(&(pMACDA->mac_da_list))) */
             
             // delete list and free resource
             list_del(&(pMACDA->mac_da_list));
-            kfree(pMACDA);
+            cs_free(pMACDA);
         }/* list_for_each_safe(nextMACDATmp, nextMACDAGrpTmp, &grp_member_head) */
     }/* if (!list_empty(&mac_da_grp_head)) */
     
diff -ruN a/drivers/net/ethernet/cs752x/src/ni/cs752x_eth.c b/drivers/net/ethernet/cs752x/src/ni/cs752x_eth.c
--- a/drivers/net/ethernet/cs752x/src/ni/cs752x_eth.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/ni/cs752x_eth.c	2016-01-20 14:57:03.456510509 +0100
@@ -65,7 +65,7 @@
 #include "cs_core_fastnet.h"
 #include "cs_core_vtable.h"
 #include "cs752x_voq_cntr.h"
-
+#include "cs_mut.h"
 #include <linux/etherhook.h>
 
 /* 3.4.11 Change for register as platform device */
@@ -157,12 +157,12 @@
 #endif
 
 #ifdef CONFIG_CS75XX_KTHREAD_RX
-  #define NETIF_RX(napi,skb,dev)	netif_rx(skb)
+  #define NETIF_RX(napi,skb,dev)	{ netif_rx(skb); }
 #else
   #ifdef CS752X_NI_NAPI
     #define NETIF_RX(napi,skb,dev)	{ if ((dev->features) & NETIF_F_GRO) napi_gro_receive(napi,skb); else netif_receive_skb(skb); }
   #else
-    #define NETIF_RX(napi,skb,dev)	netif_rx(skb)
+    #define NETIF_RX(napi,skb,dev)	{ netif_rx(skb); }
   #endif
 #endif
 
@@ -484,6 +484,7 @@
 	skb_queue_purge(&cs_ni_skb_recycle_cpu0_head);	
 #endif /* NI_RECYCLE_SKB_PER_CPU */
 }
+EXPORT_SYMBOL(clean_skb_recycle_buffer);
 #endif /* CONFIG_CS75XX_NI_EXPERIMENTAL_SW_CACHE_MANAGEMENT */
 
 u32 calc_crc(u32 crc, u8 const *p, u32 len)
@@ -838,7 +839,7 @@
 		NI_WRITEL_MODE(phy_addr, QM_CPU_PATH_LINUX0_SDRAM_ADDR + (qid * 4));
 
 #ifdef CONFIG_DEBUG_KMEMLEAK
-		skb_list_entry = kmalloc(sizeof(ni_skb_list_t), GFP_ATOMIC);
+		skb_list_entry = cs_malloc(sizeof(ni_skb_list_t), GFP_ATOMIC);
 		memset(skb_list_entry, 0x0, sizeof(ni_skb_list_t));
 		skb_list_entry->skb = skb;
 		list_add(&skb_list_entry->list,
@@ -952,7 +953,7 @@
 				ni_skb_list_t, list);
 		if (curr_skb_entry->skb == skb) {
 			list_del(&curr_skb_entry->list);
-			kfree(curr_skb_entry);
+			cs_free(curr_skb_entry);
 			return 0;
 		}
 	}
@@ -3365,8 +3366,7 @@
 
 #ifdef CONFIG_CS752X_PROC
 	if( cs_acp_enable & CS75XX_ACP_ENABLE_NI){
-		tx_desc[i] = kmalloc( NI_DMA_LSO_TXDESC_NUM * sizeof(dma_txdesc_t),
-			 GFP_KERNEL);
+		tx_desc[i] = cs_malloc( NI_DMA_LSO_TXDESC_NUM * sizeof(dma_txdesc_t), GFP_KERNEL);
 		txq_paddr[i] = virt_to_phys(tx_desc[i])|GOLDENGATE_ACP_BASE;
 		if(txq_paddr[i]& 0xF)
 			printk("@@@@@@@@@@@@@ TSO alignment error : %x @@@@@@@@@@@@@@@@@@\n",txq_paddr[i]);
@@ -6227,7 +6227,7 @@
 	tp->mdio_bus->write = &cs_mdiobus_write;
 	tp->mdio_bus->reset = &cs_mdio_reset;
 	tp->mdio_bus->phy_mask = ~(1 << tp->phy_addr);
-	tp->mdio_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	tp->mdio_bus->irq = cs_malloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
 
 	if (!tp->mdio_bus->irq) {
 		err = -ENOMEM;
@@ -6251,7 +6251,7 @@
 	return 0;
 
 err_out_free_mdio_irq:
-	kfree(tp->mdio_bus->irq);
+	cs_free(tp->mdio_bus->irq);
 err_out_free_mdio_bus:
 	mdiobus_free(tp->mdio_bus);
 err_out:
@@ -6653,6 +6653,8 @@
 	printk(KERN_INFO NI_DRIVER_NAME " built at %s %s\n", __DATE__,
 			__TIME__);
 
+	cs_kmem_cache_create();
+
 	/* debug_Aaron 2012/12/11 implement non-cacheable for performace tuning */
 #ifndef CONFIG_CS75XX_WFO
         if (ni_rx_noncache)
@@ -7016,7 +7018,7 @@
 			if (tp->phydev)
 				phy_disconnect(tp->phydev);
 			mdiobus_unregister(tp->mdio_bus);
-			kfree(tp->mdio_bus->irq);
+			cs_free(tp->mdio_bus->irq);
 			mdiobus_free(tp->mdio_bus);
 		}
 		unregister_netdev(tp->dev);
diff -ruN a/drivers/net/ethernet/cs752x/src/ni/cs75xx_pni.c b/drivers/net/ethernet/cs752x/src/ni/cs75xx_pni.c
--- a/drivers/net/ethernet/cs752x/src/ni/cs75xx_pni.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/ni/cs75xx_pni.c	2016-01-20 14:57:03.456510509 +0100
@@ -3,6 +3,7 @@
 #include <mach/cs75xx_ipc_wfo.h>
 
 #include "cs752x_eth.h"
+#include "cs_mut.h"
 
 pni_rxq_s pni_rxq[2];
 
@@ -19,14 +20,14 @@
 		printk("next %p\n", pkt->next);
 #endif
 		if (pkt->buf_addr)
-			kfree(pkt->buf_addr);
+			cs_free(pkt->buf_addr);
 
 		if (pkt->next) {
 			//printk("%s::skb %p\n\n", __func__, pkt->next->skb);
 			dev_kfree_skb_any(pkt->next->skb);
-			kfree(pkt->next);
+			cs_free(pkt->next);
 		}
-		kfree(pkt);
+		cs_free(pkt);
 	}
 	return 0;
 }
diff -ruN a/drivers/net/ethernet/cs752x/src/tm/cs75xx_tm_pol.c b/drivers/net/ethernet/cs752x/src/tm/cs75xx_tm_pol.c
--- a/drivers/net/ethernet/cs752x/src/tm/cs75xx_tm_pol.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/tm/cs75xx_tm_pol.c	2016-01-20 14:57:03.456510509 +0100
@@ -11,6 +11,7 @@
 #include <mach/cs_types.h>
 #include <mach/registers.h>
 #include "cs75xx_tm_pol.h"
+#include "cs_mut.h"
 
 static cs_tm_pol_flow_pol_db_t flow_pol_db;
 
@@ -1078,7 +1079,7 @@
 	else
 		prev->next = next->next;
 
-	kfree(next);
+	cs_free(next);
 
 	flow_pol_db.mask[id >> 5] &= ~(0x01 << (id & 0x1f));
 	flow_pol_db.used_count--;
@@ -1192,13 +1193,13 @@
 
 	p_flow_pol = find_flow_policer(id);
 	if (p_flow_pol == NULL) {
-		p_flow_pol = kmalloc(sizeof(cs_tm_pol_flow_pol_t), GFP_KERNEL);
+		p_flow_pol = cs_malloc(sizeof(cs_tm_pol_flow_pol_t), GFP_KERNEL);
 		if (p_flow_pol == NULL)
 			return -1;
 		p_flow_pol->id = id;
 		status = insert_flow_pol(p_flow_pol);
 		if (status != 0) {
-			kfree(p_flow_pol);
+			cs_free(p_flow_pol);
 			return status;
 		}
 		p_flow_pol->ref_count = 0;
diff -ruN a/drivers/net/ethernet/cs752x/src/util/cs_mut.c b/drivers/net/ethernet/cs752x/src/util/cs_mut.c
--- a/drivers/net/ethernet/cs752x/src/util/cs_mut.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/net/ethernet/cs752x/src/util/cs_mut.c	2016-01-20 14:57:03.456510509 +0100
@@ -0,0 +1,44 @@
+/*
+ * cs_mut.c: Memory Usage Tracing for Cortina NE driver
+ *
+ */
+#include <linux/version.h>
+#include <linux/types.h>
+#include "cs_mut.h"
+
+struct kmem_cache *cache_16 = NULL;	/* cache for 16-byte objects */
+
+/*************************** kmalloc family ***************************/
+
+void *cs_malloc(size_t size, gfp_t flags)
+{
+#ifdef CONFIG_CS75XX_SMALL_SLAB
+	if ((size <= 16) && (cache_16 != NULL))
+		return kmem_cache_alloc(cache_16, flags);
+	else
+		return kmalloc(size, flags);
+#else
+	return kmalloc(size, flags);
+#endif
+}
+
+void cs_free(void *ptr)
+{
+	kfree(ptr);
+}
+
+/*************************** initialization ***************************/
+
+int cs_kmem_cache_create(void)
+{
+#ifdef CONFIG_CS75XX_SMALL_SLAB
+	cache_16 = kmem_cache_create("cs75xx_cache_16", 16, 0, SLAB_PANIC, NULL);
+	if (cache_16 == NULL) {
+		printk(KERN_INFO "ERROR! Fail to create cache for 16-byte objects!\n");
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
diff -ruN a/drivers/net/ethernet/cs752x/src/util/cs_table.c b/drivers/net/ethernet/cs752x/src/util/cs_table.c
--- a/drivers/net/ethernet/cs752x/src/util/cs_table.c	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/util/cs_table.c	2016-01-20 14:57:03.456510509 +0100
@@ -1,18 +1,19 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include "cs_table.h"
+#include "cs_mut.h"
 
 cs_table_t *cs_table_alloc(unsigned int size)
 {
 	cs_table_t *new_table;
 
-	new_table = kmalloc(sizeof(cs_table_t), GFP_ATOMIC);
+	new_table = cs_malloc(sizeof(cs_table_t), GFP_ATOMIC);
 	if (new_table == NULL) return NULL;
 
-	new_table->table_head = kzalloc(sizeof(cs_table_entry_t) * size, 
-			GFP_ATOMIC);
+	new_table->table_head = cs_zalloc(sizeof(cs_table_entry_t) * size, 
+			GFP_ATOMIC);
 	if (new_table->table_head == NULL) {
-		kfree(new_table);
+		cs_free(new_table);
 		return NULL;
 	}
 
@@ -23,8 +24,8 @@
 {
 	if (p_table == NULL) return;
 	if (p_table->table_head != NULL)
-		kfree(p_table->table_head);
-	kfree(p_table);
+		cs_free(p_table->table_head);
+	cs_free(p_table);
 } /* cs_table_dealloc */
 
 cs_table_entry_t *cs_table_get_entry(cs_table_t *p_table, unsigned int index)
diff -ruN a/drivers/net/ethernet/cs752x/src/util/Makefile b/drivers/net/ethernet/cs752x/src/util/Makefile
--- a/drivers/net/ethernet/cs752x/src/util/Makefile	2016-01-20 14:50:42.664496288 +0100
+++ b/drivers/net/ethernet/cs752x/src/util/Makefile	2016-01-20 14:57:03.456510509 +0100
@@ -28,5 +28,7 @@
 
 EXTRA_CFLAGS += -I$(srctree)/drivers/net/ethernet/cs752x/src/include
 
-obj-$(CONFIG_CS752X) += cs_util.o
+obj-$(CONFIG_CS752X) += cs_util.o cs_mut.o
+
 cs_util-objs := cs_table.o
+
